(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: Fretica *) 
(* :Author: Daniel Nettels *)
(* :Summary: Summary goes here. *)
(* :Context: Fretica`Fretica` *)
(* :Package version: 1.0 *)
(* :History:  Version 1.0 October 12 2018 *)
(* :Mathematica version: 11.2.0 for Microsoft Windows (64-bit) (September 11, 2017) *)
(* :Discussion: Give more details here.*)


Get["Fretica`Usage`"];


BeginPackage["Fretica`"];


(*$FreticaExamples=FileNameJoin[{ $UserBaseDirectory,"Applications","Fretica","Documentation","Example Data"}];*)
$FreticaExamples=FileNameJoin[{ PacletObject["Fretica"]["Location"],"Example Data"}];


(* :Code Section (Call Unprotect and ClearAll): *)


(*FpdaIntrinsicDistributionPlotOptions::usage="Option of FpdaEHisto and FpdaFitEHisto";*)


(*FTSSimulateFRETStateTrajectories::usage="FTSSimulateFRETStateTrajectories[{species_Integer,rateparams:{{_?NumericQ, _?NumericQ, _?NumericQ}..},p0:{_?FRealNumberQ..},Kmatrix:_?(MatrixQ[#,FRealNumberQ]&), rcm:_?(MatrixQ[#,FRealNumberQ]&),AcceptorDirectExcitation_?NumericQ}]";*)


(*FGetPIEAnisotropyRoutes::usage="FGetPIEAnisotropyRoutes[]";*)


FShufflePhotonsForT2Alex::usage="FShufflePhotonsForT2Alex[{tdex1_Integer,tdex2_Integer},{taex1_Integer,taex2_Integer}, ADroute_Integer, AAroute_Integer]";



FPhotonTimeRelativeToMarkerHistogram::usage="FPhotonTimeRelativeToMarkerHistogram[routelist_FRouteList,markerChannel_Integer,tmaxps_Integer]";


FGetPhotonData::usage="FGetPhotonData[{\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)}, \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\)] returns all photon records of the time interval {\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)} (in units of seconds) of the detection routes specified by \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\). \!\(\*
StyleBox[\"routlist\",\nFontSlant->\"Italic\"]\) is of the form of \!\(\*FormBox[\({\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \"1\"]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[
StyleBox[\"r\", \"TI\"], \"2\"],
TraditionalForm]\), ...\!\(\*FormBox[\(}\),
TraditionalForm]\), that is a sequence of ones and zeros defining which detector routes are contained or not contained in the output.
The output of of FGetPhotonData is of the form {\!\(\*
StyleBox[\"t0\",\nFontSlant->\"Italic\"]\), { {\!\(\*SubscriptBox[
StyleBox[\"dt\",\nFontSlant->\"Italic\"], \(1\)]\), \!\(\*
StyleBox[\"route1\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"channel1\",\nFontSlant->\"Italic\"]\)}, {\!\(\*SubscriptBox[
StyleBox[\"dt\",\nFontSlant->\"Italic\"], \(2\)]\), \!\(\*
StyleBox[\"route2\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"channel2\",\nFontSlant->\"Italic\"]\)}...}}, where \!\(\*
StyleBox[\"t0\",\nFontSlant->\"Italic\"]\) is the time origin. \!\(\*
StyleBox[SubscriptBox[\"dt\", \"i\"],\nFontSlant->\"Italic\"]\) is the inter-photon time of the \!\(\*
StyleBox[\"i\",\nFontSlant->\"Italic\"]\)th photon, such that the absolute time is given by \!\(\*
StyleBox[SubscriptBox[\"t\", \"i\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)t0+\!\(\*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(i\)]\)\!\(\*
StyleBox[SubscriptBox[\"dt\", \"i\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)";


FGetPhotonDataRaw::usage="FGetPhotonDataRaw[{\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)}, \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\)] returns all photon records of the time interval {\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)} (in units of seconds) of the detection routes specified by \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\). \!\(\*
StyleBox[\"routlist\",\nFontSlant->\"Italic\"]\) is of the form of \!\(\*FormBox[\({\*SubscriptBox[
StyleBox[\"r\", \"TI\"], \"1\"]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[
StyleBox[\"r\", \"TI\"], \"2\"],
TraditionalForm]\), ...\!\(\*FormBox[\(}\),
TraditionalForm]\), that is a sequence of ones and zeros defining which detector routes are contained or not contained in the output.
The output of of FGetPhotonData is of the form {header, {dmicrotimes, routes, microtimes}} with
header: {\"MacroTimeToPicoseconds\" \[Rule] macro2ps, \"MicroTimeToPicoseconds\" \[Rule] micro2ps, }, \"StartTime\"\[Rule] t0}
dmacrotimes: List of inter-photon times. The absolute time in units of seconds is given by \!\(\*
StyleBox[SubscriptBox[\"t\", \"i\"],\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"=\",\nFontSlant->\"Italic\"]\)t0+(\!\(\*UnderoverscriptBox[\(\[Sum]\), \(k = 1\), \(i\)]\)\!\(\*
StyleBox[\"dmacrotimes\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[LeftDoubleBracket]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"i\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"\[RightDoubleBracket]\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\")\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"*\",\nFontSlant->\"Italic\"]\)macro2ps*\!\(\*SuperscriptBox[\(10\), \(-12\)]\)\!\(\*
StyleBox[\".\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\) 
microtimes: List of micro times. They need to be mutiplied with micro2ps to obtain the microtimes in picoseconds.

";


FExportTTTRToH5::usage="FExportTTTRToH5[\"\!\(\*
StyleBox[\"filename\",\nFontSlant->\"Italic\"]\).h5\", {\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)}, \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\)] exports the output of FGetPhotonDataRaw:[{\!\(\*
StyleBox[\"tstart\",\nFontSlant->\"Italic\"]\), \!\(\*
StyleBox[\"tend\",\nFontSlant->\"Italic\"]\)}, \!\(\*
StyleBox[\"routelist\",\nFontSlant->\"Italic\"]\)] into a H5 binary file named \"\!\(\*
StyleBox[\"filename\",\nFontSlant->\"Italic\"]\).h5\".";


FSetBurstList::usage="FSetBurstList[{ {\!\(\*SubscriptBox[\(t\), \(11\)]\), \!\(\*SubscriptBox[\(t\), \(12\)]\)}, {\!\(\*SubscriptBox[\(t\), \(21\)]\), \!\(\*SubscriptBox[\(t\), \(22\)]\)} ..}] sets the burst list such that the \!\(\*
StyleBox[\"i\",\nFontSlant->\"Italic\"]\)th burst starts and ends with the photons in closest proximity to \!\(\*SubscriptBox[\(t\), \(i1\)]\) and \!\(\*SubscriptBox[\(t\), \(i2\)]\), respectively.";


(*F1DHMMSetPinPfin::usages="F1DHMMSetPinPfin[pinpfin:{{{_?NumericQ..},{_?NumericQ..}}..}]";*)


FRawData::usage="Option value for FOutput, applicable e.g. in FFCS, FFCSW, FnsFCS, FTimeCorrelateWeighted, and FSimulateNanoSecondFCS";


FMLHGetLikelihoodVpeqFromK::usage="FMLHGetLikelihoodVpeqFromK[Km_?FNumericSquareMatrixQ,VList:{_?FNumericSquareMatrixQ ..}]";


FCalcAV::usage="FCalcAV[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4)&,dyeattachmentpoint:{_?NumericQ,_?NumericQ,_?NumericQ},linkerL_?NumericQ,linkerD_?NumericQ,dyeradii:{_?NumericQ,_?NumericQ,_?NumericQ},gridspaceing_?NumericQ]";


FCalcAVMinLinkerLength::usage="FCalcAVMinLinkerLength[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4&),dyeparams:{{{_?NumericQ,_?NumericQ,_?NumericQ},_?NumericQ,_?NumericQ,_?NumericQ}..},gridspaceing_?NumericQ]";


FTRBPInit::usage="FTRBPInit[minmaxpos_,kofflist_,prlist_,pDifflist_,statelist_]";
FTRBPGetKMatrix::usage="FTRBPGetKMatrix[]";
FTRBPGetPeq::usage="FTRBPGetPeq[]";
FTRBPGetPeqFast::usage="FTRBPGetPeqFast[]";
FTRBPSimulatePhotonByPhotonTrace::usage="FTRBPSimulatePhotonByPhotonTrace[params:{{photonrates_?FNumericMatrixQ,pini:{_?NumericQ..},t_}..}]";
FTRBPSimulateBinnedTrace::usage="FTRBPSimulateBinnedTrace[params:{{(*photonrates*)_?FNumericMatrixQ,(*pini:*){_?NumericQ..},(*t*)_}..},binning_]";


FTimeCorrelateWeighted::usage="FTimeCorrelateWeighted[ { {t11, w11}, {t12, w12}},..}, { {t21, w21}, {t22, w22}},..}, taumin, taumax, \!\(\*
StyleBox[\"inttime2realtime\",\nFontSlant->\"Italic\"]\)] correlates to time series using weights. FTimeCorrelateWeighted uses the algorithm described by Wahl et al. (https://doi.org/10.1364/OE.11.003583). The weights wij are real numbers. taumin and taumax define the wanted range of lagtimes (in real time units). Multiplication with \!\(\*
StyleBox[\"inttime2realtime\",\nFontSlant->\"Italic\"]\) converts from integer time units to real time units.  

Options:
\!\(\*FormBox[\(\\\ \\\ \),
TraditionalForm]\)FOutput\!\(\*FormBox[\(\[Rule]\),
TraditionalForm]\)FData (default) or FOutput\!\(\*FormBox[\(\[Rule]\),
TraditionalForm]\)FGraph or FOutput\!\(\*FormBox[\(\[Rule]\),
TraditionalForm]\)FRawData
\!\(\*FormBox[\(\\\ \\\ \),
TraditionalForm]\)FNumberOfStepsInCascade\!\(\*FormBox[\(\[Rule]\),
TraditionalForm]\)10 (default) or any other integer value \!\(\*FormBox[\(>\),
TraditionalForm]\)0
";


F1DHMMGetLogLikelihoodList::usage="F1DHMMGetLogLikelihoodList[] returns list with the loglikelihoods of each trajectory that where calculated in the last call of F1DHMMLogLikelihood"


FHMMGetLogLikelihoodList::usage="FHMMGetLogLikelihoodList[] returns list with the loglikelihoods of each trajectory that where calculated in the last call of FHMMLogLikelihood."


FGetRouteAssignment::usage="FGetRouteAssignment[] returns a list with the route assginment for all detectors for the main channels.";
FGetPIERouteAssignment::usage="FGetPIERouteAssignment[] returns a list with the route assginment for all detectors for the PIE channels";
FGetRoutes::usage="FGetRoutes[{\"A\"|\"D\",\"P\"|\"S\"}] or FGetRoutes[\"A\"|\"D\"], or FGetRoutes[\"P\"|\"S\"] return the detection route numbers corresponding to assignment of color and/or polarisation for the main channels.";
FGetPIERoutes::usage="FGetPIERoutes[{\"A\"|\"D\",\"P\"|\"S\"}] or FGetPIERoutes[\"A\"|\"D\"], or FGetPIERoutes[\"P\"|\"S\"] return the detection route numbers corresponding to assignment of color and/or polarisation for the PIE channels";

FGetRouteList::usage="FGetRouteList[routesnumbers:{_Integer..}] or FGetRouteList[routeassignment]  returns a routelist. For example FGetRouteList[\"A\"] might return {1,0,1,0,0,0} or  FGetRouteList[{1,4}] returns {1,0,0,1,0,0} ";


FPIECorrectionFactors::usage="FPIECorrectionFactors[EappDonly_,SappAonly_,{ {Eapp1, Sapp1}, {Eapp2, Sapp2 }..}] returns the FRET correction factors calculated from the peak positions in the Sapp vs Eapp 2D histogram.";
FSetFretCorrectionFactors::usage="FSetFretCorrectionFactors[{\[Alpha], \[Beta], \[Gamma], \[Gamma]pie}, G] changes the FRET correction setting according to the values provided. The RCM is constructed according to the current detection routes assignment."; 


FFCSModel::usage="FFCSModel[{{\!\(\*SubscriptBox[\(n\), \(1\)]\),\!\(\*SubscriptBox[\(Q1\), \(1\)]\),\!\(\*SubscriptBox[\(Q2\), \(1\)]\),\!\(\*SubscriptBox[\(\[Tau]diff\), \(1\)]\),{{\!\(\*SubscriptBox[\(c1\), \(1\)]\),\!\(\*SubscriptBox[\(\[Tau]1\), \(1\)]\)},{\!\(\*SubscriptBox[\(c2\), \(1\)]\),\!\(\*SubscriptBox[\(\[Tau]2\), \(1\)]\)}..}}, {\!\(\*SubscriptBox[\(n\), \(2\)]\),\!\(\*SubscriptBox[\(Q1\), \(2\)]\),\!\(\*SubscriptBox[\(Q2\), \(2\)]\),\!\(\*SubscriptBox[\(\[Tau]diff\), \(2\)]\),{{\!\(\*SubscriptBox[\(c1\), \(2\)]\),\!\(\*SubscriptBox[\(\[Tau]1\), \(2\)]\)},{\!\(\*SubscriptBox[\(c2\), \(2\)]\),\!\(\*SubscriptBox[\(\[Tau]2\), \(2\)]\)}..}}..},a , bg1, bg2][t] retruns FCS model for the given parameters as a function of t."


FMakePeakModel2D::usage="FMakePeakModel2D[peaknames] returns a {model, var}, where model is function with 2D Gaussian peaks. The peaks are assigned to symbols listed in peaknames. For example peaknames={\"a\",\"b\",...}. var is the list of peak parameters.";
FFitPeaks2DMakeGuess::usage="FFitPeaks2DMakeGuess[xyfdata, peaknames, positionguess:{{_?NumericQ,_?NumericQ}..}] returns a list of initial guesses for the model defined by FMakePeakModel2D[peaknames] based on the density data xyfdat and the xy positions defined in positionguess.";
FFitPeaks2D::usage="FFitPeaks2D[xyfdata, peaknames, guess] or FFitPeaks2D[xyfdata, peaknames, positionguess:{{_?NumericQ,_?NumericQ}..} fits peaks in a 2D distribution  yxfdata with 2D Gaussians. The peaks to be fit are assigned to symbols listed in peaknames.";


(* :Code Section: *)


(* :Error Messages: *)


FOpenTTTR::filenotexist="The file \"`1`\" does not exist."; 
FOpenHistoData::filenotexist="The file \"`1`\" does not exist."; 
FSetRCM::filenotexist="The file \"`1`\" does not exist."; 


FHMMSetPhotonRates::dimerr="Photon rate vectors are of unequal lenght.";
FHMMSetPhotonRates::noinit="HMM system is not initialized.";
FHMMLogLikelihood::erroptval=FHMMViterbi::erroptval="FHMMpinpfin: Unknown option value.";
FHMMLogLikelihood::noinit=FHMMViterbi::noinit="HMM system is not initialized";
FHMMLogLikelihood::dimerr=FHMMViterbi::dimerr="Missmatch of dimensions.";


FpdaFitEHisto::dimerr="Mismatch between number of peaks and number of burst size distributions.";


(* :Code Section: *)


Begin["`Private`"];



Fretica = Which[
$System=="Microsoft Windows (64-bit)", Install[PacletObject["Fretica"]["AssetLocation","Fretica64_exe"]],
$System=="Microsoft Windows (32-bit)",(*Install["Fretica\\Fretica32.exe"]*)"Microsoft Windows (32-bit) is not supported",
True, "Could not link to Fretica"
]
(*
Install[LinkConnect["freti"]];
*)s
(*Set up FreticaDocumentation Kernel*)
Block[{op},op=EvaluatorNames/.Options[$FrontEnd,EvaluatorNames];
If[!MemberQ[op[[All,1]],"FreticaDocumentation"],SetOptions[$FrontEnd,EvaluatorNames->Join[op,{"FreticaDocumentation"->{"AutoStartOnLaunch"->False}}]]];
]


(* :Code Section: *)


XYFromYGraph[wg_YGraph]:=Module[{x0=WGx0/.wg[[1]]//N,dx=WGdx/.wg[[1]]//N,length=Length[wg[[2]]]},If[length>0,{NestList[(#+dx)&,x0,length-1],wg[[2]]}//Transpose,{}]]
HistogramFromYGraph[wg_YGraph]:=Module[{x0=WGx0/.wg[[1]]//N,dx=WGdx/.wg[[1]]//N,length=Length[wg[[2]]]},{NestList[(#+dx)&,x0+0.5 dx,length-1],wg[[2]],Table[dx,{i,length}]}//Transpose]



(*Options[Histo]={FOutput->FGraph}~Join~Options[FPlotHisto];
Histo[dat_List,{min_,max_,dx_}, opts:OptionsPattern[]]:=Module[{histo},
histo=BinCounts[dat,{min,max,dx}];
histo=Table[{min+(i-0.5)dx,histo[[i]],dx},{i,Length[histo]}];
If[OptionValue[FOutput]===FGraph,
FPlotHisto[histo,FilterRules[{opts}, Options[FPlotHisto]],ImageSize->400,AspectRatio->1/2,Axes->False,Frame->True,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},FrameStyle-> Directive[Black,AbsoluteThickness[1]]]
,histo]
]*)


Options[Histo]={FOutput->FGraph}~Join~Options[Histogram];
Histo[dat_List|dat_WeightedData,{min_,max_,dx_}, opts:OptionsPattern[]]:=Module[{histo},
If[OptionValue[FOutput]===FGraph,
Histogram[dat,{min,max,dx},FilterRules[{opts}, Options[Histogram]],ImageSize->400,AspectRatio->1/2,Axes->False,Frame->True,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},FrameStyle-> Directive[Black,AbsoluteThickness[1]]]
,(histo=HistogramList[dat,{min,max,dx}][[2]];
histo=Table[{min+(i-0.5)dx,histo[[i]],dx},{i,Length[histo]}];
histo)]
]


(* ::Input::Initialization:: *)
Options[FPlotHisto]=Options[Histogram];
FPlotHisto[dat:{{_,_,_},{_,_,_}..},opts:OptionsPattern[]]:=Module[{xmin,xmax,dx},
dx=dat[[1,3]];
xmin=dat[[1,1]]-dx/2;
xmax=dat[[-1,1]]+dx/2;
Histogram[WeightedData[dat[[All,1]],dat[[All,2]]],{xmin,xmax,dx},FilterRules[{opts}, Options[Histogram]]]
];
FPlotHisto[dat:{{{_,_,_},{_,_,_}..}..},opts:OptionsPattern[]]:=Module[{xmin,xmax,dx},
dx=dat[[1,1,3]];
xmin=dat[[1,1,1]]-dx/2;
xmax=dat[[1,-1,1]]+dx/2;
Histogram[MapThread[WeightedData,{dat[[All,All,1]],dat[[All,All,2]]}],{xmin,xmax,dx},FilterRules[{opts}, Options[Histogram]]]
]


Options[Histo2D]={FOutput->FGraph}~Join~Options[ListContourPlot]~Join~Options[ListPlot3D];
Histo2D[dat:{{_,_}..},{min1_,max1_,d1_},{min2_,max2_,d2_}, opts:OptionsPattern[]]:=Module[{bc,xv,yv,xyz},
bc=BinCounts[dat,{min1,max1,d1},{min2,max2,d2}];
xv=Drop[Range[min1+0.5 d1,max1+0.5 d1,d1],-1];
yv=Drop[Range[min2+0.5 d2,max2+0.5 d2,d2],-1];
xyz=Flatten[Table[{xv[[i]],yv[[j]],bc[[i,j]]},{i,1,Length[xv]},{j,1,Length[yv]}],1];
Which[OptionValue[FOutput]===FGraph,
ListContourPlot[xyz,FilterRules[{opts}, Options[ListContourPlot]],ColorFunction->(If[#!=0,Hue[(0.75-.75#)],White]&),LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},PlotRange->Automatic,FrameStyle-> Directive[Black,AbsoluteThickness[0.8]],ImageSize-> 400,AspectRatio->1/GoldenRatio]
,OptionValue[FOutput]===FGraph3D
,ListPlot3D[xyz,FilterRules[{opts}, Options[ListPlot3D]],LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},PlotRange->Automatic]
,True,xyz
]
]


IsInPolygonQ::usage="
  IsInPolygonQ[{testx,testy},{{x1,y1},{x2,y2},...}] return true if {testx,testy} in inside polygon. 
  Polygon can be closed or not. A point will be inside exactly one member of a polygonal partitioning.
  C-code by W. Randolph Franklin (http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html). 
  J. Wesenberg, 2008";
IsInPolygonQ[{testx_,testy_},pts_List]:=Xor@@((Xor[#[[1,2]]>testy,#[[2,2]]>testy]&&((testx-#[[2,1]])<(#[[1,1]]-#[[2,1]]) (testy-#[[2,2]])/(#[[1,2]]-#[[2,2]])))&/@Partition[pts,2,1,{2,2}])




Options[FFindGlobalFit]=Options[FindFit];
FFindGlobalFit[dats_,models_List,guess_,var_,opts:OptionsPattern[]]:=Module[{gm,gdat,pars,n,gvar},
pars=guess[[All,1]];gdat=Flatten[Table[Map[{i}~Join~#&,dats[[i]]],{i,1.,Length[dats]}],1];
gvar=If[ListQ[var],var,{var}];gm[i_?NumberQ][v_,p_]:=models[[Round[i]]]/.(Map[Rule[#[[1]],#[[2]]]&,{pars,p}\[Transpose]])/.(Map[Rule[#[[1]],#[[2]]]&,{gvar,v}\[Transpose]]);FindFit[gdat,gm[n][gvar,pars],guess,Join[{n},gvar],FilterRules[{opts}, Options[FindFit]]]
]
FFindGlobalFit[dats_,models_List,constraints_,guess_,var_,opts:OptionsPattern[]]:=Module[{gm,gdat,gvar,pars,n},
pars=guess[[All,1]];gdat=Flatten[Table[Map[{i}~Join~#&,dats[[i]]],{i,1.,Length[dats]}],1];
gvar=If[ListQ[var],var,{var}];gm[i_?NumberQ][v_,p_]:=models[[Round[i]]]/.(Map[Rule[#[[1]],#[[2]]]&,{pars,p}\[Transpose]])/.(Map[Rule[#[[1]],#[[2]]]&,{gvar,v}\[Transpose]]);FindFit[gdat,{gm[n][gvar,pars],constraints},guess,Join[{n},gvar],FilterRules[{opts}, Options[FindFit]]]
]



Options[FNonlinearModelGlobalFit]=Options[NonlinearModelFit];
FNonlinearModelGlobalFit[dats_,models_List,guess_,var_,opts:OptionsPattern[]]:=
Module[{gm,gdat,gvar,pars,n},
pars=guess[[All,1]];gdat=Flatten[Table[Map[{i}~Join~#&,dats[[i]]],{i,1.,Length[dats]}],1];
gvar=If[ListQ[var],var,{var}];gm[i_?NumberQ][v_,p_]:=models[[Round[i]]]/.(Map[Rule[#[[1]],#[[2]]]&,{pars,p}\[Transpose]])/.
(Map[Rule[#[[1]],#[[2]]]&,{gvar,v}\[Transpose]]);
NonlinearModelFit[gdat,gm[n][gvar,pars],guess,Join[{n},gvar],FilterRules[{opts},Options[NonlinearModelFit]]]
]

FNonlinearModelGlobalFit[dats_,models_List,constraints_,guess_,var_,opts:OptionsPattern[]]:=Module[{gm,gdat,gvar,pars,n},
pars=guess[[All,1]];gdat=Flatten[Table[Map[{i}~Join~#&,dats[[i]]],{i,1.,Length[dats]}],1];  
gvar=If[ListQ[var],var,{var}];gm[i_?NumberQ][v_,p_]:=models[[Round[i]]]/.(Map[Rule[#[[1]],#[[2]]]&,{pars,p}\[Transpose]])/.(Map[Rule[#[[1]],#[[2]]]&,{gvar,v}\[Transpose]]); NonlinearModelFit[gdat,{gm[n][gvar,pars],constraints},guess,Join[{n},gvar],FilterRules[{opts},Options[NonlinearModelFit]]]
]



(*Options[FLMFit]=Options[FindMinimum];*)
Clear[FLMFit]
FLMFit[dat:{{_?NumberQ,_?NumberQ}..},modelfunc_,guess:{{_,_?NumberQ}..}|{{_,_?NumberQ,_?NumberQ}..}]:=Module[{f,R,chisq,params,fitresult,tmp},
params=guess[[All,1]];
f[var:{___?NumberQ}]:=(modelfunc/.Map[Rule@@#&,{params,var}\[Transpose]])[dat[[All,1]]];
R[var:{___?NumberQ}]:=(tmp=f[var];(tmp-dat[[All,2]])/Sqrt[tmp]);
chisq[var:{___?NumberQ}]:=(tmp=R[var];tmp . tmp);
If[MatchQ[guess,{{_,_?NumberQ}..}],
fitresult=FindMinimum[1,guess,Method->{"LevenbergMarquardt","Residual"->R[params]}];fitresult[[1]]*=2./Length[tmp],
fitresult=FindMinimum[chisq[params],guess];fitresult[[1]]*=1./Length[tmp]];
fitresult
]

FLMFit[dat:{{{_?NumberQ,_?NumberQ}..}..},modelfunc_,guess:{{_,_?NumberQ}..}|{{_,_?NumberQ,_?NumberQ}..},opts:OptionsPattern[]]:=Module[{f,R,chisq,params,fitresult,tmp},
params=guess[[All,1]];f[var:{___?NumberQ}]:=Flatten[Map[#[[1]][#[[2]]]&,{(modelfunc/.Map[Rule@@#&,{params,var}\[Transpose]]),dat[[All,All,1]]}\[Transpose]]];R[var:{___?NumberQ}]:=(tmp=f[var];(tmp-Flatten[dat[[All,All,2]]])/Sqrt[tmp]);
chisq[var:{___?NumberQ}]:=(tmp=R[var];tmp . tmp);
If[MatchQ[guess,{{_,_?NumberQ}..}],
fitresult=FindMinimum[1,guess,Method->{"LevenbergMarquardt","Residual"->R[params]}];fitresult[[1]]*=2./Length[tmp],
fitresult=FindMinimum[chisq[params],guess];fitresult[[1]]*=1./Length[tmp]];
fitresult
]


Clear[FReadCoordinatesFromImage];
SetAttributes[FReadCoordinatesFromImage,HoldFirst]
FReadCoordinatesFromImage[outputcurve_,image_]:=Module[{whiteLocatorRing,color,thickness,size,radius,lineThickness,opacity,help},
Manipulate[
help="Operation sequence
1. Enter the reference points at the plot x axes into the input fields.
2. Alt+Click on the point with x-coordinate x1. This brings up the first locator visible as a circle. Alt+Click (Command + Click for Mac OS X) on that with x2 which gives rise to the second locator. Adjust the locators, if necessary. Press the button \"Set x scale\".
3. Enter the reference points at the plot y axes into the input fields. Press Enter. Move the two already existing locators to the points with the coordinates y1 and y2. Press the button \"Set y scale\". Now the both scales are captured.
4. Move the two already existing locators to the first two points of the curve to be captured. Alt+Click on other points of the curve. Each Alt+Click will generate an additional locator. Adjust locators, if necessary. To remove, press Alt+Click on unnecessary locators.
5. Press the button \"Update 'listOfPoints'\". This assigns the captured list to the global variable listOfPoints. Done.

(Adapted from 'copyCurve' of Alexei Boulbitch, see http://mathematica.stackexchange.com";
DynamicModule[{pts={},x1=Null,x2=Null,y1=Null,y2=Null,X1,X2,Y1,Y2,\[CapitalDelta]X,\[CapitalDelta]Y,g,myRound},
myRound[x_]:=Round[1000*x]/1000//N;
(*Begins the column with all the content of the manipulate*)Column[{(*Begin LocatorPane*)Row[{Dynamic@LocatorPane[Union[Dynamic[pts]],Dynamic@Show[{Image[image,ImageSize->size],Graphics[{color,AbsoluteThickness[lineThickness],Opacity[opacity],Line[Union[pts]]}]}],LocatorAutoCreate->True,
(*Begin Locator appearance*)Appearance->If[whiteLocatorRing,
Graphics[{{color,AbsoluteThickness[thickness],Circle[{0,0},radius+thickness/2]},{White,AbsoluteThickness[thickness],Circle[{0,0},radius]}},ImageSize->10],Graphics[{{color,AbsoluteThickness[thickness],Circle[{0,0},radius+thickness/2]}},ImageSize->10]](*End Locator appearance*)],Tooltip[Style["Help",Bold],help]}],(*End LocatorPane*)(*Begin of the block of InputFields*)
Row[{Spacer[20],Button[Style["Clear",Bold],pts={};]}],Row[{Style["\!\(\*SubscriptBox[\(x\), \(1\)]\):"],InputField[Dynamic[x1],FieldHint->"Type  \!\(\*SubscriptBox[\(x\), \(1\)]\)",FieldSize->7,FieldHintStyle->{Red}],Spacer[20],Style["   \!\(\*SubscriptBox[\(y\), \(1\)]\):"],InputField[Dynamic[y1],FieldHint->"Type  \!\(\*SubscriptBox[\(y\), \(1\)]\)",FieldSize->7,FieldHintStyle->{Red}]}],Row[{Style["\!\(\*SubscriptBox[\(x\), \(2\)]\):"],InputField[Dynamic[x2],FieldHint->"Type \!\(\*SubscriptBox[\(x\), \(2\)]\)",FieldSize->7,FieldHintStyle->{Red}],Spacer[20],Style["   \!\(\*SubscriptBox[\(y\), \(2\)]\):"],InputField[Dynamic[y2],FieldHint->"Type  \!\(\*SubscriptBox[\(y\), \(2\)]\)",FieldSize->7,FieldHintStyle->{Red}]}],(*End of the block of InputFields*)(*Begin the buttons row*)
Row[{Spacer[15],(*Begin button "Memorize scale X"*)
Button["Set x scale",X1=Min[Transpose[myRound/@Union[pts]][[1]]];
X2=Max[Transpose[myRound/@Union[pts]][[1]]];
\[CapitalDelta]X=X2-X1;],(*End of button "Memorize scale X"*)Spacer[70],
(*Begin button "Memorize scale Y"*)
Button["Set y scale",Y1=Min[Transpose[myRound/@Union[pts]][[2]]];
Y2=Max[Transpose[myRound/@Union[pts]][[2]]];
\[CapitalDelta]Y=Y2-Y1;](*End of button "Memorize scale Y"*)}],(*End the buttons row*)Spacer[0],
(*Begin button "Make the list of the curve's points"*)
Button[Style["Write coordinates to '"<>SymbolName[Unevaluated[outputcurve]]<>"'",Bold],g[{a_,b_}]:={(x1*X2-x2*X1)/\[CapitalDelta]X+a/\[CapitalDelta]X*Abs[x2-x1],(y1*Y2-y2*Y1)/\[CapitalDelta]Y+b/\[CapitalDelta]Y*Abs[y2-y1]};
Clear[outputcurve];
outputcurve=Map[myRound,Map[g,pts]]](*End of button "Make the list..."*)}
,Alignment->Center
](*End of column with all the content of the manipulate*)
],(*End of the DynamicModule*)
(*The massive of sliders begins*)Column[{Row[{Control[{{whiteLocatorRing,True,"white locator ring"},{True,False}}],Spacer[50]}],Row[{Spacer[32.35],Control[{{size,450, "image size"},300,800}],Spacer[38.5`],Control[{{opacity,0.5,"Opacity"},0,1}]}],Row[{Spacer[10.],Control[{{thickness,1,"Circle thickness"},0.5,5}],Spacer[13.65],Control[{{lineThickness,1,"Line thickness"},0,10}]}],Row[{Spacer[22.8],Control[{{color,Red,"Color"},Red}],Spacer[59.3],Control[{{radius,0.5,"Radius"},0,3}]}]},Alignment->Center],
(*The massive of sliders ends*)(*Definitions of sliders*)ControlType->{Checkbox,Slider,Slider,Slider,Slider,ColorSlider,Slider},ControlPlacement->Top,SaveDefinitions->True,FrameLabel->{{None,None},{None,Style["Curve reader",Bold]}}]
];


FUnlinkFretica[]:=Uninstall[Fretica]


FAboutFretica[]:=FPAboutFretica[] 


FNumberOfRoutes=6;
FMaxChannel=32767;


FGetMaxChannel[]:=FMaxChannel;


FRouteList={Repeated[0|1,FNumberOfRoutes]};


FExpandRoutelist[rlist_List]:=PadRight[rlist,FNumberOfRoutes]


FRouteListToByte[route:FRouteList]:=Total@MapIndexed[#1 2^(#2[[1]]-1)&,FExpandRoutelist@route]


FValidRouteQ[route_]:=(IntegerQ[route] && 1<=route<=FNumberOfRoutes)
FValidChannelQ[ch_]:=(IntegerQ[ch] && 1<=ch<=FMaxChannel)


FChannelConstraintsList={Repeated[{_?FValidChannelQ,_?FValidChannelQ},{FNumberOfRoutes}]};


FMakeChannelList[ch:{_?FValidChannelQ,_?FValidChannelQ}]:=ConstantArray[ch,FNumberOfRoutes]


FRealNumberQ=NumberQ[#]&&!MatchQ[#,_Complex]&;


FPowerSpectrum[xydat_,first\[Nu]_]:=Module[{fft,dt,\[Nu]max,length,\[Delta]\[Nu],\[Nu]0,result},
fft=Fourier[xydat[[All,2]]];
dt=xydat[[2,1]]-xydat[[1,1]];
\[Nu]max=(1 0.5)/ dt;
length=Length[fft];\[Delta]\[Nu]=1./(length dt);\[Nu]0=(first\[Nu]-1) \[Delta]\[Nu];
result=2. dt Abs[Take[fft,{first\[Nu],Floor[length/2+1]}]]^2;
{Table[\[Nu]0+(i-1)\[Delta]\[Nu],{i,Length[result]}],result}\[Transpose]
]
FPowerSpectrum[xydat_]:=FPowerSpectrum[xydat,1]


FNumericMatrixQ[m_]:=MatrixQ[m,NumericQ]
FNumericSquareMatrixQ[m_]:=SquareMatrixQ[m] && MatrixQ[m,NumericQ]


Options[FPlotContourHisto]=Options[ListLinePlot];
FPlotContourHisto[histodat:{{_,_,_}...},opts:OptionsPattern[]]:=Module[{pts},
pts=Map[Sequence@@{{#[[1]]-0.5#[[3]],#[[2]]},{#[[1]]+0.5#[[3]],#[[2]]}}&,histodat];
ListLinePlot[pts,Evaluate@FilterRules[{opts},Options[ListLinePlot]],PlotRange->All]
]

FPlotContourHisto[histodat:{{{_,_,_}...}..},opts:OptionsPattern[]]:=Module[{pts},
pts=Map[Sequence@@{{#[[1]]-0.5#[[3]],#[[2]]},{#[[1]]+0.5#[[3]],#[[2]]}}&];
ListLinePlot[pts/@histodat,Evaluate@FilterRules[{opts},Options[ListLinePlot]],PlotRange->All]
]


Options[FOpenTTTR]={FCopyToLocalDisk->False};

FOpenTTTR[filename_String,opts:OptionsPattern[]]:=Module[{tmp,i=2,result},
If[FileExistsQ[filename],
FMaxChannel=If[FileExtension[filename]==="ht3",32767,32767(*4096*)];
If[OptionValue[FCopyToLocalDisk]==True,(
tmp=$TemporaryDirectory<>FileNameTake[filename];
While[FileExistsQ[tmp],
(tmp=FileNameSplit[tmp];tmp[[-1]]="v"<>ToString[i]<>tmp[[-1]];i++;tmp=FileNameJoin[tmp];)];CopyFile[filename,tmp];
result=FOpenT3r[StringReplace[ExpandFileName[tmp],"\\"->"/"]];
DeleteFile[tmp];
result)
,FOpenT3r[StringReplace[ExpandFileName[filename],"\\"->"/"]]
]
,Message[FOpenTTTR::filenotexist,filename]]
]
FOpenTTTR[]:=Module[{fn=SystemDialogInput["FileOpen",{NotebookDirectory[],{"TTTR"->{"*.t3r","*.pt2","*.pt3","*.ht2","*.ht3","*.ptu"}}}]},
If[fn===$Canceled,fn, FOpenTTTR[fn]]
]
FOpenTTTR[filename_String,{tstartSec_?NumberQ,tstopSec_?NumberQ}]:=Module[{tmp,t1=tstartSec,t2=tstopSec},
If[t1<0,t1=0];
If[t2<0,t2=0];
If[t1>t2,(tmp=t1;t1=t2;t2=tmp;)];
If[FileExistsQ[filename],FOpenT3r[StringReplace[ExpandFileName[filename],"\\"->"/"],N@t1,N@t2],Message[FOpenTTTR::filenotexist,filename]]
]


FSaveAsHT3[filename_String]:=Module[{fn},
fn=StringReplace[ExpandFileName[filename],"\\"->"/"];
If[!FileExistsQ[fn],FPSaveAsHt3[fn],0]

]


FTTTRCreationTime[]:= DateList[FTTTRCreationDateStr[]]


FGetFromHeader[s_String]:=ToExpression[StringCases[FShowHeader[],s~~Whitespace~~":"~~Whitespace~~v:NumberString..->v][[1]]]


FGetMarkerList[]:=FPGetMarkerList[]


FGetT3rFilename[]:=FPGetT3rFilename[];


FGetStartTime[]:=FPGetStartTime[];
FGetStopTime[]:=FPGetStopTime[];



FOpenHistoData[filename_String]:=
Module[{},
If[FileExistsQ[filename],
Which[
FileExtension[filename]=="phd" || FileExtension[filename]=="hhd",
(
(*XYFromYGraph/@(List@@ToExpression[FOpenHHDStr[StringReplace[ExpandFileName[filename],"\\"->"/"]]])*)
FOpenHHDStr[StringReplace[ExpandFileName[filename],"\\"->"/"]]
)
,FileExtension[filename]=="phu",
(
{#[[1]]10.^9 Range[Length[#[[2]]]],#[[2]]}\[Transpose]&/@FPOpenPHU[ExpandFileName[filename]]
)
,True,{}
]
,Message[FOpenHistoData::filenotexist,filename]]
]
FOpenHistoData[]:=Module[{fn=SystemDialogInput["FileOpen",{NotebookDirectory[],{"TTTR"->{"*.phu","*.phd","*.hhd"}}}]},
If[fn===$Canceled,fn, FOpenHistoData[fn]]
]


FGetRCM[]:=FGetRCMStr[]
FSetRCM[rcm_?(MatrixQ[#,NumberQ]&& Apply[SameQ,Dimensions[#]]&)]:=Module[{dim=Length[rcm],newrcm=PadRight[N@rcm,{FNumberOfRoutes,FNumberOfRoutes}],i},If[dim<FNumberOfRoutes,For[i=dim+1,i<=FNumberOfRoutes,i++,newrcm[[i,i]]=1]];FSetRCMStr[newrcm]]
FSetRCM[filename_String]:=Module[{rcm,fn},
fn=If[DirectoryQ[filename], SystemDialogInput["FileOpen",{filename,{"Alle Files"->{"*"}}}],filename];
If[FileExistsQ[fn],(FPLoadRCM[StringReplace[ExpandFileName[filename],"\\"->"/"]];FGetRCM[]), Message[FSetRCM::filenotexist,filename]]
]

FSetRCM[]:=Module[{fn=SystemDialogInput["FileOpen",{NotebookDirectory[],{"Alle Files"->{"*"}}}]},
If[fn===$Canceled,fn, FSetRCM[fn]]
]


FGetActiveRoutes[]:=FPActiveDetectionRoutes[]
FSetActiveRoutes[routes:FRouteList]:=(FPSetActiveDetectionRoutes[FExpandRoutelist@routes];FPActiveDetectionRoutes[])


FSetDirectAcceptorExcitation[value_?NumberQ]:=FPSetDirectAcceptorExcitation[N[value]]


FSetAnisotropyL1[value_?NumberQ]:=FPSetAnisotropyL1[N@value]
FSetAnisotropyL2[value_?NumberQ]:=FPSetAnisotropyL2[N@value]


FGetDonorRoutes[]:=FPGetDonorRoutes[];
FSetDonorRoutes[routes:FRouteList]:=(FPSetDonorRoutes[FExpandRoutelist@routes];FPGetDonorRoutes[])

FGetAcceptorRoutes[]:=FPGetAcceptorRoutes[];
FSetAcceptorRoutes[routes:FRouteList]:=(FPSetAcceptorRoutes[FExpandRoutelist@routes];FPGetAcceptorRoutes[])


FSetFRETRoutes[val:{Repeated["D"|"A"|0,FNumberOfRoutes]}]:=Module[{v=PadRight[val,FNumberOfRoutes]},

FSetDonorRoutes[v/.{"D"->1,"A"->0}];
FSetAcceptorRoutes[v/.{"D"->0,"A"->1}];
]
FGetFRETRoutes[]:=Module[{a,d},
d=FGetDonorRoutes[]/. {1->"D",0->1};
a=FGetAcceptorRoutes[]/. {1->"A",0->1};
a*d/. {1->0}
]


FSetAnisotropyRoutes[main:{Repeated["P"|"S"|0,FNumberOfRoutes]}, pie:{Repeated["P"|"S"|0,FNumberOfRoutes]}]:=
Module[{
m=PadRight[main,FNumberOfRoutes],
p=PadRight[pie,FNumberOfRoutes]
},
FPSetMainChannelAnisotropyRoutes[m/.{"P"->1,"S"->0}, m/.{"P"->0,"S"->1}];
FPSetPIEChannelAnisotropyRoutes[p/.{"P"->1,"S"->0}, p/.{"P"->0,"S"->1}];
]
FSetAnisotropyRoutes[val:{Repeated["P"|"S"|0,FNumberOfRoutes]}]:=FSetAnisotropyRoutes[val, val];

FGetAnisotropyRoutes[]:=
Module[{p,s},
{p,s}=FPGetMainChannelAnisotropyRoutes[];
{p,s}={p/. {1->"P",0->1},s/. {1->"S",0->1}};
p*s/. {1->0}
]

FGetPIEAnisotropyRoutes[]:=
Module[{p,s},
{p,s}=FPGetPIEChannelAnisotropyRoutes[];
{p,s}={p/. {1->"P",0->1},s/. {1->"S",0->1}};
p*s/. {1->0}
]


FShiftPhotonTimesByPicoseconds[dtps:{_Integer..}]:=FPShiftPhotonTimesByPicoseconds[dtps]


FShiftPhotonTimesByPicoseconds[dt_Integer,route_Integer]:=Module[{dtlist},
If[route<=0,Return [0]];
dtlist=ConstantArray[0,route];dtlist[[-1]]=dt;FShiftPhotonTimesByPicoseconds[dtlist]
]


FGetRouteAssignment[]:={"A"FGetAcceptorRoutes[]+"D"FGetDonorRoutes[],FGetAnisotropyRoutes[]}\[Transpose]
FGetPIERouteAssignment[]:={"A"FGetAcceptorRoutes[]+"D"FGetDonorRoutes[],FGetPIEAnisotropyRoutes[]}\[Transpose]

FGetRoutes[{fretch:"A"|"D",polarization:"P"|"S"}]:=
Position[FGetRouteAssignment[],{fretch,polarization}]//Flatten
FGetRoutes[fretch:"A"|"D"]:=
Position[FGetRouteAssignment[],{fretch,_}]//Flatten
FGetRoutes[polarization:"P"|"S"]:=
Position[FGetRouteAssignment[],{_,polarization}]//Flatten

FGetPIERoutes[{fretch:"A"|"D",polarization:"P"|"S"}]:=
Position[FGetPIERouteAssignment[],{fretch,polarization}]//Flatten
FGetPIERoutes[fretch:"A"|"D"]:=
Position[FGetPIERouteAssignment[],{fretch,_}]//Flatten
FGetPIERoutes[polarization:"P"|"S"]:=
Position[FGetPIERouteAssignment[],{_,polarization}]//Flatten


FGetRouteList[routes:{_Integer..}]:=Block[{rl=ConstantArray[0,6]},rl[[routes]]=1;rl]
FGetRouteList[routes_]:=FGetRouteList[FGetRoutes[routes]]


FPIECorrectionFactors[Edonly_,Saonly_,EvsSfret:{{_,_},{_,_}..}]:=Module[{\[Alpha]H,\[Beta]H,\[Gamma]H,\[Delta]H,esc,es,e,fit,\[Gamma],\[Beta]},
\[Alpha]H=Mean@Flatten@{Edonly/(1-Edonly)};
\[Gamma]H=1;
\[Beta]H=1;
\[Delta]H=Mean@Flatten@{Saonly/(1-Saonly)};
esc[{eapp_,sapp_}]:={(sapp (eapp+(-1+eapp) \[Alpha]H)+(-1+sapp) \[Delta]H)/(-\[Delta]H+sapp (-\[Alpha]H+eapp (1+\[Alpha]H-\[Gamma]H)+\[Gamma]H+\[Delta]H)),1+(-1+sapp)/(1-\[Beta]H \[Delta]H+sapp (-1+\[Beta]H (-\[Alpha]H+eapp (1+\[Alpha]H-\[Gamma]H)+\[Gamma]H+\[Delta]H)))};
es=esc/@EvsSfret;
fit=NonlinearModelFit[es,(1+\[Gamma] \[Beta] +(1-\[Gamma])\[Beta] e)^-1,{{\[Gamma],1.},{\[Beta],1.}},e];
{\[Beta]H,\[Gamma]H}={\[Beta],\[Gamma]}/.fit["BestFitParameters"];
{"Fretica\[Alpha]\[Beta]\[Gamma]\[Gamma]pie"->{(\[Delta]H \[Beta]H)/(1+\[Delta]H \[Beta]H) ,\[Alpha]H,\[Gamma]H,1/\[Beta]H},"Hellenkamp\[Alpha]\[Beta]\[Gamma]\[Delta]"->{\[Alpha]H,\[Beta]H,\[Gamma]H,\[Delta]H},"EvsScorrected"->esc/@EvsSfret,"\[Gamma]fit"->fit}
]


FSetFretCorrectionFactors[{\[Alpha]_ ,\[Beta]_,\[Gamma]_,\[Gamma]pie_},G_]:=Module[{rcm,routes=FGetRouteAssignment[]},

rcm=Outer[List,routes,routes,1]/.{
{{"A","P"},{"A","P"}}->1,{{"D","P"},{"D","P"}}->\[Gamma],{{"A","P"},{"D","P"}}->-\[Beta],{{"A","S"},{"A","S"}}->G,{{"D","S"},{"D","S"}}->G \[Gamma],{{"A","S"},{"D","S"}}->-\[Beta] G}/.{{_,_},{_,_}}->0;
{FSetRCM[rcm],FSetDirectAcceptorExcitation[\[Alpha]],FSetPIEGamma[\[Gamma]pie]}
]
FSetFretCorrectionFactors[{\[Alpha]_ ,\[Beta]_,\[Gamma]_,\[Gamma]pie_}]:=FSetFretCorrectionFactors[{\[Alpha] ,\[Beta],\[Gamma],\[Gamma]pie},1]


FEnableChannelConstraints[enable:True|False]:=If[enable,FEnableChannelConstraints[1],FEnableChannelConstraints[0]]


FGetChannelConstraints[route_?FValidRouteQ]:=ToExpression[FGetChannelConstraintsStr[route-1]]
FGetChannelConstraints[]:=Map[FGetChannelConstraints,Range[FNumberOfRoutes]]


FSetChannelConstraints[route_?FValidRouteQ,{ch1_?FValidChannelQ,ch2_?FValidChannelQ}]:=ToExpression@FSetChannelConstraintsStr[route-1,{ch1,ch2}]
FSetChannelConstraints[{ch1_?FValidChannelQ,ch2_?FValidChannelQ}]:=Map[FSetChannelConstraints[#,{ch1,ch2}]&,Range[FNumberOfRoutes]]


FEnablePie[enable:True|False]:=If[enable,FEnablePie[1],FEnablePie[0]]


FGetPIERoutes[]:=FPGetPIERoutes[];
FSetPIERoutes[routes:FRouteList]:=(FPSetPIERoutes[FExpandRoutelist@routes];FPGetPIERoutes[])


FGetPIEChannelConstraints[route_?FValidRouteQ]:=ToExpression[FGetPIEChannelConstraintsStr[route-1]]
FGetPIEChannelConstraints[]:=Map[FGetPIEChannelConstraints,Range[FNumberOfRoutes]]


FSetPIEChannelConstraints[route_?FValidRouteQ,{ch1_?FValidChannelQ,ch2_?FValidChannelQ}]:=ToExpression@FSetPIEChannelConstraintsStr[route-1,{ch1,ch2}]
FSetPIEChannelConstraints[{ch1_?FValidChannelQ,ch2_?FValidChannelQ}]:=Map[FSetPIEChannelConstraints[#,{ch1,ch2}]&,Range[FNumberOfRoutes]]


FSetPIEGamma[gamma_?NumberQ]:=FPSetPIEGamma[N[gamma]]
FGetPIEGamma[]:=FPGetPIEGamma[]


FPIEChannelSelector[routelist_List]:=Module[{dat,maxy,lp,c1,c2,ntot},
dat=FLifeTimeHisto[FRoutes->routelist,FOutput->FData,FPhotonData->All];
dat[[All,All,1]]=Range[Length[dat[[1,All,1]]]];(*replace time by channel (bin) number*)
ntot=Map[Total,dat[[All,All,2]]\[Transpose]];
c1=LengthWhile[ntot,#==0&]+1;(*find first non-empty bin*)
c1=If[c1>FMaxChannel  || c1<1,1,c1];
c2=Length[ntot]-LengthWhile[Reverse@ntot,#==0&];
c2=If[c2>FMaxChannel || c2<1,FMaxChannel,c2];
dat=dat[[All,c1;;c2]];
dat[[All,All,2]]=Map[Log[10,#]&,dat[[All,All,2]]]/.Indeterminate->0;
(*dat=dat[[All,c1;;c2]];*)
maxy=Max[dat[[All,All,2]]];
lp=ListPlot[dat,PlotRange->All,PlotStyle->{Darker@Red,Darker@Green}];
Manipulate[FSetChannelConstraints[{t1fret,t2fret}];FSetPIEChannelConstraints[{t1pie,t2pie}];FPIEChannelSelectorFirst=False;
Show[lp,Graphics[{
{Green,Line[{{t1fret,0},{t1fret,maxy}}],
Line[{{t2fret,0},{t2fret,maxy}}],
{Opacity[0.1],Green,Rectangle[{t1fret,0},{t2fret,maxy}]}},
{Red,Line[{{t1pie,0},{t1pie,maxy}}],
Line[{{t2pie,0},{t2pie,maxy}}],
{Opacity[0.1],Red,Rectangle[{t1pie,0},{t2pie,maxy}]}}
}],Frame->True,PlotRange->{{c1,c2},All},AspectRatio->0.2,ImageSize->600,Axes->False,FrameLabel->{"channel number","\!\(\*SuperscriptBox[\(10\), \(x\)]\)"}
]
,{{t1fret,c1,"FRET ch1"},c1,c2,1},{{t2fret,c1,"FRET ch2"},c1,c2,1},{{t1pie,c1,"PIE ch1"},c1,c2,1},{{t2pie,c1,"PIE ch2"},c1,c2,1}]
]


FShufflePhotonsForT2Alex[{tdex1_Integer,tdex2_Integer},{taex1_Integer,taex2_Integer}, ADroute_Integer, AAroute_Integer]:=FPShuffelPhotonsForT2Alex[tdex1,tdex2,taex1,taex2,ADroute-1,AAroute-1]


FPhotonTimeRelativeToMarkerHistogram[routelist:FRouteList,markerChannel_Integer,tmaxps_Integer,binning_Integer]:=FPPhotonTimeRelativeToMarkerHistogram[routelist,markerChannel,tmaxps,binning]


FReturnChannelConstraintsFromOption[opt_]:=Module[{},
Which[
opt===Automatic,Automatic,
opt===None,FMakeChannelList[{1,FMaxChannel}],
MatchQ[opt,{_?FValidChannelQ,_?FValidChannelQ}],FMakeChannelList[opt],
MatchQ[opt,FChannelConstraintsList],opt,
True,(Message[FChannelConstraints::invalid];Automatic)
]
]
FReturnTimeintervalFromOption[opt_]:=Module[{},
Which[
opt===All,All,
MatchQ[opt,{_?NumberQ,_?NumberQ}],opt,
True,(Message[FTimeWindow::invalid];All)
]
]


FChannelConstraints::invalid="Invalid channel range option. Automatic is used.";


FTimeWindow::invalid="Invalid time interval option. All is used.";


Options[FPCH] = {FOutput -> FGraph,FTimeWindow->All,FChannelConstraints->Automatic}~Join~Options[ListLogPlot];

FPCH[routes : {FRouteList ...}, binwidthMs_?NumberQ, opts : OptionsPattern[]] := 
Module[{dat,timeinterval,ch},
ch=FReturnChannelConstraintsFromOption[OptionValue[FChannelConstraints]];timeinterval=FReturnTimeintervalFromOption[OptionValue[FTimeWindow]];
dat=
Map[(
Which[
ch=== Automatic && timeinterval === All,FPPCH[FRouteListToByte[#], N[binwidthMs]],
ch=== Automatic ,FPPCH2[FRouteListToByte[#], N[binwidthMs],N@timeinterval[[1]],N@timeinterval[[2]]],timeinterval === All, FPPCH4[FRouteListToByte[#], N[binwidthMs],Flatten[ch]],
True,FPPCH3[FRouteListToByte[#], N[binwidthMs],N@timeinterval[[1]],N@timeinterval[[2]],Flatten[ch]]]
)&,FExpandRoutelist/@routes];
If[OptionValue[FOutput] === FGraph,
ListLogPlot[dat, FilterRules[{opts}, Options[ListLogPlot]], ImageSize -> 400, AspectRatio -> 1/2, Axes -> False, Frame -> True, FrameLabel -> {"photons in bin", "frequency"}, PlotLabel -> "PCH (time binning: " <> ToString[binwidthMs] <> "ms)", LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 12, FontWeight -> Bold}, FrameStyle -> Directive[Black, AbsoluteThickness[1]]]
,dat]
]

FPCH[routes: FRouteList, binwidthMs_?NumberQ, opts : OptionsPattern[]]:=Module[{pch=FPCH[{routes}, binwidthMs, opts ]},If[OptionValue[FOutput] === FGraph,pch,pch[[1] ]]];
(*
FPCH[routes: FRouteList, binwidthMs_?NumberQ, opts : OptionsPattern[]] := Module[{dat},
dat =FPCH[{FExpandRoutelist@routes} ,binwidthMs,FOutput-> FData,opts ];
If[OptionValue[FOutput] === FGraph,
ListLogPlot[dat, FilterRules[{opts}, Options[ListLogPlot]], ImageSize -> 400, AspectRatio -> 1/2, Axes -> False, Frame -> True, FrameLabel -> {"photons in bin", "frequency"}, PlotLabel -> "PCH (time binning: " <> ToString[binwidthMs] <> "ms)", LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 12, FontWeight -> Bold}, FrameStyle -> Directive[Black, AbsoluteThickness[1]]],
dat
]
]
*)
FPCH[binwidthMs_?NumberQ, opts : OptionsPattern[]] := FPCH[{1, 1, 1, 1}, binwidthMs, opts]



FPCH3DG::overflow="Numerical Error";


FPCH3DG[nmax_Integer,species:{{_?NumberQ,_?NumberQ}..},nbg_?NumberQ,F1_?NumberQ,F2_?NumberQ]:= {Range[0,nmax],FP3DGPCH[nmax,N@species[[All,1]],N@species[[All,2]],N@nbg,N@F1,N@F2]}\[Transpose]


FPCHFida[nmax_Integer,species:{{_?NumberQ,_?NumberQ}..},nbg_?NumberQ,dvdx:{{_?NumberQ,_?NumberQ}..}]:= {Range[0,nmax],FPPCHdVdX[nmax,N@species[[All,1]],N@species[[All,2]],N@nbg,N@Flatten[dvdx]]}\[Transpose]


Options[FPCHFidaFit]={FConstraints->None}~Join~ Options[ListLogPlot];
FPCHFidaFit[pchdat:{{_?NumericQ,_?NumericQ}..},species:{{_,_}..},nbg_,dvdx:{{_,_?NumericQ}..},guess:{{_,_?NumberQ}..},opts:OptionsPattern[]]:=Module[{chisq,nbins,nmax,params,f,R,objectiveFunction,fitresult,modelpch},
nbins=Total[pchdat[[All,2]]] ;
nmax=Length[pchdat]-1;
params=guess[[All,1]];
f[var:{___?NumberQ}]:=(FPCHFida[nmax,Abs@species,Abs@nbg ,dvdx]/.Map[Rule@@#&,{params,var}\[Transpose]])[[All,2]];

R[{vars___?NumericQ}]:=Module[{model,\[Sigma]sqr},
model=f[{vars}];
\[Sigma]sqr=Abs[nbins model (1-model)];
(nbins model-pchdat[[All,2]])/Sqrt[\[Sigma]sqr]
];
objectiveFunction[{vars___?NumericQ}]:=Norm[R[{vars}],2];
If[OptionValue[FConstraints]=!=None,fitresult=FindMinimum[{objectiveFunction[params],OptionValue[FConstraints]},guess,PrecisionGoal->4,AccuracyGoal->4],fitresult=FindMinimum[objectiveFunction[params],guess,PrecisionGoal->4,AccuracyGoal->4,Method->{"LevenbergMarquardt","Residual"->R[params]}];fitresult[[1]]*=2.;
];
fitresult[[1]]/=(nmax-Length[guess]);
modelpch=FPCHFida[nmax,Abs@species,Abs@nbg,dvdx]/.Rule@@@Transpose[{params,params/.fitresult[[2]]}];
modelpch[[All,2]]*=nbins;
fitresult~Join~{Show[ListLogPlot[pchdat,PlotRange->All],ListLogPlot[{modelpch},PlotRange->All,Joined->True],FilterRules[{opts}, Options[ListLogPlot]],PlotRange->All, AspectRatio -> 1/2, Axes -> False, Frame -> True, FrameLabel -> {"photons in bin", "frequency"}, LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 10, FontWeight -> Bold}, FrameStyle -> Directive[Black, AbsoluteThickness[1]]]}
]


Options[FPCHFidaGlobalFit]={FConstraints->None}~Join~ Options[ListLogPlot];
FPCHFidaGlobalFit[pchdat:{{{{_?NumericQ,_?NumericQ}..},{{_,_}..},_}..},dvdx:{{_,_?NumericQ}..},guess:{{_,_?NumberQ}..},opts:OptionsPattern[]]:=Module[{chisq,nbins,nmax,params,f,R,objectiveFunction,fitresult,modelpch,dat,modelparams},
dat=pchdat[[All,1,All,2]];
modelparams=pchdat[[All,2;;3]];
nbins=Map[Total,dat] ;
nmax=Map[Length,dat]-1;

params=guess[[All,1]];
f[var:{___?NumberQ}]:=MapThread[(FPCHFida[#1,Abs@#2[[1]],Abs@#2[[2]] ,dvdx]/.Rule@@@Transpose[{params,var}])[[All,2]]&,{nmax,modelparams}];

R[{vars___?NumericQ}]:=Module[{model,\[Sigma]sqr},
model=f[{vars}];
\[Sigma]sqr=Abs[nbins model (1-model)];
Flatten[(nbins model-dat)/Sqrt[\[Sigma]sqr]]
];
R[guess[[All,2]]];
objectiveFunction[{vars___?NumericQ}]:=Norm[R[{vars}],2];
If[OptionValue[FConstraints]=!=None,fitresult=FindMinimum[{objectiveFunction[params],OptionValue[FConstraints]},guess,PrecisionGoal->4,AccuracyGoal->4],fitresult=FindMinimum[objectiveFunction[params],guess,PrecisionGoal->4,AccuracyGoal->4,Method->{"LevenbergMarquardt","Residual"->R[params]}];fitresult[[1]]*=2.;
];
fitresult[[1]]/=(Total[nmax]-Length[guess]);
modelpch=MapThread[FPCHFida[#1,Abs@#2[[1]],Abs@#2[[2]],dvdx]&,{nmax,modelparams}]/.Rule@@@Transpose[{params,params/.fitresult[[2]]}];
modelpch[[All,All,2]]*=nbins;
modelpch;
fitresult~Join~{Show[ListLogPlot[pchdat[[All,1]],PlotRange->All],ListLogPlot[modelpch,PlotRange->All,Joined->True],FilterRules[{opts}, Options[ListLogPlot]],PlotRange->All, AspectRatio -> 1/2, Axes -> False, Frame -> True, FrameLabel -> {"photons in bin", "frequency"}, LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 10, FontWeight -> Bold}, FrameStyle -> Directive[Black, AbsoluteThickness[1]]]}
]


FSetBurstList[timeintervals:{ {_?NumericQ, _?NumericQ} ..}]:=FPSetBurstList[N@timeintervals]


Options[FFindBurstsDeltaT]={FPIEBurstIdentificationMethod->FMainChannelAboveThreshold};
FFindBurstsDeltaT[\[CapitalDelta]t_?NumberQ,minburstcount_?NumberQ,maxburstcount_?NumberQ,opts:OptionsPattern[]]:=
Module[{tA,tD},
If[OptionValue[FPIEBurstIdentificationMethod]=!=FDualChannelBurstSearch,
FFindBurstsDeltaTP[N[\[CapitalDelta]t],Round[minburstcount],Round[maxburstcount],Which[OptionValue[FPIEBurstIdentificationMethod]===FMainChannelAboveThreshold,0,OptionValue[FPIEBurstIdentificationMethod]===FMainChannelOrPieChannelAboveThreshold,1,OptionValue[FPIEBurstIdentificationMethod]===FMainChannelPlusPieChannelAboveThreshold,2,
OptionValue[FPIEBurstIdentificationMethod]===FPieChannelAboveThreshold,3,True,0]]
,
((*DCBS*)
FFindBurstsDeltaT[\[CapitalDelta]t,minburstcount,maxburstcount,FPIEBurstIdentificationMethod->FMainChannelAboveThreshold];
tD=Interval@@Transpose[FGetFromBurstList[{"StartTime","EndTime"}]];
FFindBurstsDeltaT[\[CapitalDelta]t,minburstcount,maxburstcount,FPIEBurstIdentificationMethod->FPieChannelAboveThreshold];
tA=Interval@@Transpose[FGetFromBurstList[{"StartTime","EndTime"}]];
FSetBurstList[List@@IntervalIntersection[tA,tD]]
)
]
]


Options[FFindBurstsFromTimeBinnedData]={FCombineContiguousBins->True,FPIEBurstIdentificationMethod->FMainChannelAboveThreshold};
FFindBurstsFromTimeBinnedData[binwidth_?NumberQ,minbincount_?NumberQ,minburstcount_?NumberQ,maxburstcount_?NumberQ,opts:OptionsPattern[]]:=Module[{tA,tD},
If[OptionValue[FPIEBurstIdentificationMethod]=!=FDualChannelBurstSearch,
FPFindBurstsBinning[N[binwidth],N[minbincount],N[minburstcount],Round[maxburstcount],If[OptionValue[FCombineContiguousBins]==True,1,0],Which[OptionValue[FPIEBurstIdentificationMethod]===FMainChannelAboveThreshold,0,OptionValue[FPIEBurstIdentificationMethod]===FMainChannelOrPieChannelAboveThreshold,1,OptionValue[FPIEBurstIdentificationMethod]===FMainChannelPlusPieChannelAboveThreshold,2,OptionValue[FPIEBurstIdentificationMethod]===FPieChannelAboveThreshold,3,True,0]]
,
((*DCBS*)
FFindBurstsFromTimeBinnedData[binwidth,minbincount,minburstcount,maxburstcount,FPIEBurstIdentificationMethod->FMainChannelAboveThreshold,FCombineContiguousBins->True];
tD=Interval@@Transpose[FGetFromBurstList[{"StartTime","EndTime"}]];
FFindBurstsFromTimeBinnedData[binwidth,minbincount,minburstcount,maxburstcount,FPIEBurstIdentificationMethod->FPieChannelAboveThreshold,FCombineContiguousBins->True];
tA=Interval@@Transpose[FGetFromBurstList[{"StartTime","EndTime"}]];
FSetBurstList[List@@IntervalIntersection[tA,tD]]
)
]
]


FSplitBursts[t_?FRealNumberQ]:=FSplitburstsP[t*1000.];



FExpandBurstsSymmetrically[t_?FRealNumberQ]:=FExpandBurstsSymmetricallyP[N[t]];


Options[FMCStrace]={FOutput->FGraph,Weights->{1},FShowBursts->False,FShowBurstsLevel->10,FBurstData->All}~Join~Options[ListLogPlot];



FMCStrace[routes:{FRouteList..}|{{FRouteList,{_?FValidChannelQ,_?FValidChannelQ}}..},binwidthMs_?NumberQ,t1_?NumberQ,t2_?NumberQ, opts:OptionsPattern[]]:=
Module[{dat,mcs,bl,blevel,weights,f},
weights=PadRight[OptionValue[Weights],Length[routes],1];
f[{r:FRouteList,{c1_,c2_}}]:=FPPhotonTrajectoryWithChannelConstraints[FRouteListToByte[FExpandRoutelist@r],N@binwidthMs,N@t1,N@t2,c1-1,c2-1];
dat=If[MatchQ[routes,{FRouteList..}]
,FPPhotonTrajectory[FRouteListToByte/@routes,N@binwidthMs,N@t1,N@t2]
,Map[f,routes]];
dat[[All,All,2]]*=weights;If[OptionValue[FOutput]===FGraph,(mcs=ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,ImageSize->600,AspectRatio->0.2,Axes->False,Frame->True,FrameLabel->{"time (sec)","photons"},PlotStyle->{Red,Green,Darker[Red],Darker[Green]},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},FrameStyle-> Directive[Black,AbsoluteThickness[1]]];If[OptionValue[FShowBursts]==True,(bl=FGetFromBurstList[{"StartTime","EndTime"},FilterRules[{opts}, Options[FGetFromBurstList]]]\[Transpose];bl=Select[bl,t1<#[[1]]<t2&];blevel=OptionValue[FShowBurstsLevel];Show[mcs,Graphics[{AbsoluteThickness[2],Map[Line[{{#[[1]],blevel},{#[[2]],blevel}}]&,bl]}],PlotRange->All]),mcs]),(*else*)
dat
]
]


Options[FDeleteTTTRTimeInterval] = {FCloseGap -> True};
FDeleteTTTRTimeInterval[times:{{_?NumberQ,_?NumberQ}..},opts : OptionsPattern[]]:=FPDeleteTTTRTimeIntervals[N@Flatten@times,If[OptionValue[FCloseGap]===True,1,0]];
FDeleteTTTRTimeInterval[t1sec_?NumberQ,t2sec_?NumberQ,opts : OptionsPattern[]]:=FPDeleteTTTRTimeIntervals[{N@t1sec,N@t2sec},If[OptionValue[FCloseGap]===True,1,0]];



Options[FLifeTimeHisto]={FOutput->FGraph,FPhotonData->FBursts,FRoutes->All}~Join~Options[ListLogPlot];
FLifeTimeHisto[opts:OptionsPattern[]]:=Module[{dat,routes,mode=0},
routes=OptionValue[FRoutes];
Which[
routes===All,routes=Range[FNumberOfRoutes],
MatchQ[routes,{_Integer..}],True,
True, Return[$Failed]
];
Which[
OptionValue[FPhotonData]===All,mode=0,
OptionValue[FPhotonData]===FBursts,mode=1,
OptionValue[FPhotonData]===FNonBursts,mode=2,
OptionValue[FPhotonData]===FSelectedBursts,mode=3,
True, Return[$Failed]
];
dat=Map[FPLifeTimeHisto[#-1,mode]&,routes];
If[OptionValue[FOutput]===FGraph,ListLogPlot[dat,FilterRules[{opts}, Options[ListLogPlot]],FrameLabel->{"ns",None},Axes->False,Frame->True,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},FrameStyle-> Directive[Black,AbsoluteThickness[1]],PlotRange->All,PlotStyle->{Red,Green,Darker[Red],Darker[Green]}]
,dat
]
]



FConvolve[irf:{{_,_}..},timeshift_Integer,model_][times:{_?NumericQ..}]:=Module[{irfdat,modeldat},
modeldat=ListConvolve[N@RotateRight[irf[[All,2]],timeshift],model[times],1];
{times,modeldat}\[Transpose]
]

Options[FLifeTimeFit]={FOutput -> FGraph}~Join~Options[ListLogPlot];
FLifeTimeFit[dat:{{_?NumberQ,_?NumberQ}..},irf:{{_?NumberQ,_?NumberQ}..},modelfunc_,guess:{{_,_?NumberQ}..}|{{_,_?NumberQ,_?NumberQ}..},timeshift_Integer,opts : OptionsPattern[]]:=Module[{times,func,fitresult,fitdat,residuals},
times=dat[[All,1]];
func[t:{_?NumericQ..}]:=FConvolve[irf,timeshift,modelfunc][t][[All,2]];
fitresult=FLMFit[dat,func,guess];
fitdat=FConvolve[irf,timeshift,modelfunc/.fitresult[[2]]][times];
residuals={dat[[All,1]],dat[[All,2]]-fitdat[[All,2]]}\[Transpose];
If[OptionValue[FOutput] === FGraph,
{fitresult,
ListLogPlot[{dat,fitdat},Evaluate@FilterRules[{opts}, Options[ListLogPlot]],PlotRange->All,Frame->True,Axes->False],
ListPlot[residuals,PlotRange->All,Frame->True,Axes->False]},
{fitresult,fitdat,residuals}
]
]
FLifeTimeFit[dat:{{{_?NumberQ,_?NumberQ}..}..},irf:{{{_?NumberQ,_?NumberQ}..}..},modelfunc_,guess:{{_,_?NumberQ}..}|{{_,_?NumberQ,_?NumberQ}..},timeshift:{_Integer..},opts : OptionsPattern[]]:=Module[{times,func,fitresult,fitdat,residuals,model},
times=dat[[All,All,1]];
func[i_][t_]:=FConvolve[irf[[i]],timeshift[[i]],modelfunc[[i]]][ t ][[All,2]];
model=Table[func[i],{i,Length[modelfunc]}];
fitresult=FLMFit[dat,model,guess];
fitdat=Table[FConvolve[irf[[i]],timeshift[[i]],modelfunc[[i]]/.fitresult[[2]]][times[[i]]],{i,Length[modelfunc]}];
residuals=Table[{dat[[i,All,1]],dat[[i,All,2]]-fitdat[[i,All,2]]}\[Transpose],{i,Length[modelfunc]}];
If[OptionValue[FOutput] === FGraph,
{fitresult,
Table[ListLogPlot[{dat[[i]],fitdat[[i]]},FilterRules[{opts}, Options[ListLogPlot]],PlotRange->All,Frame->True,Axes->False],{i,Length[modelfunc]}],
Table[ListPlot[residuals[[i]],PlotRange->All,Frame->True,Axes->False],{i,Length[modelfunc]}]},
{fitresult,fitdat,residuals}
]

]


FDetermineBackground[]:=FPDetermineBackground[]
FGetBackground[]:=FPGetBackground[]
FSetBackground[bg:{Repeated[_?NumberQ,FNumberOfRoutes]}]:=FPSetBackground[N/@FExpandRoutelist@bg]


FGetPIEBackground[]:=FPGetPIEBackground[]
FSetPIEBackground[bg:{Repeated[_?NumberQ,FNumberOfRoutes]}]:=FPSetPIEBackground[N/@FExpandRoutelist@bg]


Options[FGetFromBurstList]={FBurstData->All};
(*SetAttributes[FGetFromBurstList,HoldFirst];*)
FGetFromBurstList[param_String,opts:OptionsPattern[]]:=
Which[
OptionValue[FBurstData]===All,FPGetFromBurstList[param]
,OptionValue[FBurstData]===FSelectedBursts,FPGetSelectedFromBurstList[param]
,True,{}
]
FGetFromBurstList[expr_,opts:OptionsPattern[]]:=ReleaseHold[expr/.param_String:>  FGetFromBurstList[param,opts]]



SetAttributes[FGetFromBurst,HoldFirst];
FGetFromBurst[param_String,burstindex_Integer]:=If[1<=burstindex<=FGetBurstListSize[],FPGetFromBurst[param,burstindex-1],Null]

FGetFromBurst[expr_,burstindex_Integer]:=ReleaseHold[expr/.param_String:>  FGetFromBurst[param,burstindex]]




Options[FParamHisto]=Join[Options[Histo],Options[FGetFromBurstList]];
FParamHisto[param_,{min1_,max1_,d1_},opts:OptionsPattern[]]:=Histo[FGetFromBurstList[param,FilterRules[{opts}, Options[FGetFromBurstList]]],{min1,max1,d1},FilterRules[{opts}, Options[Histo]],FrameLabel->{param,"Number of bursts"}]



FParamHisto2D[param1_,param2_,{min1_,max1_,d1_},{min2_,max2_,d2_},opts:OptionsPattern[]]:=Histo2D[{FGetFromBurstList[param1,FilterRules[{opts}, Options[FGetFromBurstList]]],FGetFromBurstList[param2,FilterRules[{opts}, Options[FGetFromBurstList]]]}\[Transpose],{min1,max1,d1},{min2,max2,d2},FilterRules[{opts}, Options[Histo2D]],FrameLabel->{param1,param2}]


(*
SetAttributes[FSelectBursts,HoldFirst]
FSelectBursts[paramlist_List,crit_]:=Module[{bl,sel},
bl=FGetFromBurstList[paramlist,FBurstData->All]\[Transpose];
sel=Map[TrueQ[crit[#]]&,bl]/.{True->1,False->0};
MapIndexed[FPSelectBurst[#2[[1]],#1]&,sel];
]
*)



FSelectBursts[paramlist_List,crit_]:=Module[{bl,sel},
bl=FGetFromBurstList[paramlist,FBurstData->All]\[Transpose];
sel=Map[TrueQ[crit[#]]&,bl]/.{True->1,False->0};
FPSelectBursts[sel]
]


FSelectBurst[index_Integer,val_Integer]:=FPSelectBurst[index,val]


FGetPhotonList[t1_?NumberQ,t2_?NumberQ]:=FGetPhotonInformation[N@t1,N@t2]


FBurstPhotonExport[filename_String]:=Module[{fn},
fn=StringReplace[ExpandFileName[filename],"\\"->"/"];
FBurstPhotonExportP[fn]
]


FLogNormal[e_,pos_,ampl_,width_,asym_]:=Piecewise[{{Abs[ampl] 2^(-(Log[1+((asym^2-1)(e-pos))/(asym width)]^2/Log[asym]^2)),((asym^2-1) (e-pos))/(asym width)>-1},{0,((asym^2-1) (e-pos))/(asym width)<=-1}}]
FGaussian[e_,pos_,ampl_,width_]:=Abs[ampl] Exp[-((e-pos)^2/(2 width^2))]


FLogNormal[pos_,ampl_,width_,asym_]:=Function[{Global`e},FLogNormal[Global`e,pos,ampl,width,asym]]
FGaussian[pos_,ampl_,width_]:=Function[{Global`e},FGaussian[Global`e,pos,ampl,width]]


FMakeFRETPeakModel[peaks:{Repeated["G"|"L"]}]:=Module[{modelrules,paramrules,varrules,pos,ampl,width,asym},modelrules={"G"->FGaussian[pos,ampl,width],"L"->FLogNormal[pos,ampl,width,asym]};paramrules={"G"->List[pos,ampl,width],"L"->List[pos,ampl,width,asym]};varrules[i_]:={pos->Pos[i],ampl->Ampl[i],width->Width[i],asym->Asym[i]};
{MapIndexed[(#1/.modelrules)/.varrules[#2[[1]]]&,peaks],MapIndexed[(#1/.paramrules)/.varrules[#2[[1]]]&,peaks]}
]

FMakeFRETPeakModel[peaks:{Repeated["G"|"L"]},numberofmodels_Integer]:=Module[{model,var,j},
model=FMakeFRETPeakModel[peaks];model=Table[model/.var_Symbol[j_Integer]->var[i,j],{i,numberofmodels}]\[Transpose];model[[2]]=Flatten[model[[2]]];
model
]


FMakeFRETPeakModel[peaks:{Repeated["G"|"L"]},numberofmodels_,globalparams:{_Symbol[_Integer]..}]:=Module[{model,rules},
model=FMakeFRETPeakModel[peaks,numberofmodels];
rules=Map[(#[[0]][i_,#[[1]]]->#)&,globalparams];
model=model/.rules;
model[[2]]=DeleteDuplicates[model[[2]]];
model
]
FMakeFRETPeakModel[peaks:{Repeated["G"|"L"]},numberofmodels_,{}]:=FMakeFRETPeakModel[peaks,numberofmodels]


FMakeModel[peaks:{Repeated["G"|"L"]}]:=Module[{modelrules,paramrules,varrules,pos,ampl,width,asym},modelrules={"G"->FGaussian[Global`e,pos,ampl,width],"L"->FLogNormal[Global`e,pos,ampl,width,asym]};paramrules={"G"->List[pos,ampl,width],"L"->List[pos,ampl,width,asym]};varrules[i_]:={pos->Pos[i],ampl->Ampl[i],width->Width[i],asym->Asym[i]};
{MapIndexed[(#1/.modelrules)/.varrules[#2[[1]]]&,peaks],MapIndexed[(#1/.paramrules)/.varrules[#2[[1]]]&,peaks]}
]

FMakeModel[peaks:{Repeated["G"|"L"]},numberofmodels_Integer]:=Module[{model},
model=FMakeModel[peaks];model=Table[model/.var_Symbol[j_Integer]->var[i,j],{i,numberofmodels}]\[Transpose];model[[2]]=Flatten[model[[2]]];
model
]


FMakeModel[peaks:{Repeated["G"|"L"]},numberofmodels_,globalparams:{_Symbol[_Integer]..}]:=Module[{model,rules},
model=FMakeModel[peaks,numberofmodels];
rules=Map[(#[[0]][i_,#[[1]]]->#)&,globalparams];
model=model/.rules;
model[[2]]=DeleteDuplicates[model[[2]]];
model
]
FMakeModel[peaks:{Repeated["G"|"L"]},numberofmodels_,{}]:=FMakeModel[peaks,numberofmodels]


FFindGuess[dat:{{_?NumberQ,_?NumberQ,___}..},peaks:{Repeated["G"|"L"]},peakpos:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]}]:=Module[{paramlist,tmpdat,GetPos,GetAmpl},
paramlist=FMakeFRETPeakModel[peaks][[2]];
GetPos[i_]:=If[NumberQ[peakpos[[i]]],peakpos[[i]],
(tmpdat=Select[dat,IntervalMemberQ[Interval[peakpos[[i]]], #[[1]]]&];Select[dat,#[[2]]==Max[tmpdat[[All,2]]]&][[1,1]])];GetAmpl[i_]:=Select[dat,Nearest[dat[[All,1]],GetPos[i]][[1]]==#[[1]]&][[1,2]];Flatten[Map[{#,#/.{Pos[i_]:> GetPos[i],Ampl[i_]:> GetAmpl[i],Width[i_]->0.12,Asym[i_]->0.9}}\[Transpose]&,paramlist],1]
]


FFindGuess[dat:{{{_?NumberQ,_?NumberQ,___}..}..},peaks:{Repeated["G"|"L"]},peakpos:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]}]:=Module[{paramlist,guess},
paramlist=FMakeFRETPeakModel[peaks,Length[dat]][[2]];
guess=Flatten[Map[FFindGuess[#,peaks,peakpos]&,dat],1];
guess[[All,1]]=paramlist;
guess
]


FFindGuess[dat:{{{_?NumberQ,_?NumberQ,___}..}..},peaks:{Repeated["G"|"L"]},globalparams:{_Symbol[_Integer]..},peakpos:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]}]:=
Module[{paramlist,guess,globalguess},
paramlist=FMakeFRETPeakModel[peaks,Length[dat],globalparams][[2]];
guess=FFindGuess[dat,peaks,peakpos];
globalguess=Map[#->Mean[Cases[guess,{#[[0]][_Integer,#[[1]]],_}][[All,2]]]&,globalparams];
guess=Map[Rule@@#&,guess];
{paramlist,paramlist/.guess/.globalguess}\[Transpose]
]



Options[FPlotFRETFit]={FFitCurveOptions->{PlotRange->All},FSubPopOptions->{PlotRange->All},FFitCurveStyle->{Gray,AbsoluteThickness[2]},FSubPopStyle->Automatic}~Join~Options[Graphics]~Join~Options[Plot]~Join~Options[FPlotHisto];
FPlotFRETFit[histodat:{{_?NumberQ,_?NumberQ,_?NumberQ}..},peaks:{Repeated["G"|"L"]},fitresult_,opts:OptionsPattern[]]:=Module[{model,pldat,plfit,plsubpop,subfunc,e},model[e_]=Through[(FMakeFRETPeakModel[peaks][[1]]/.fitresult)[e]];pldat=FPlotHisto[histodat,FilterRules[{opts}, Options[FPlotHisto]],PlotRange->All];
plfit=Plot[
Evaluate[Total[model[e]]],{e,Min[histodat[[All,1]]],Max[histodat[[All,1]]]},Evaluate@OptionValue[FFitCurveOptions],PlotRange->All,PlotStyle->OptionValue[FFitCurveStyle]
];
plsubpop=Plot[
Evaluate[model[e]],{e,Min[histodat[[All,1]]],Max[histodat[[All,1]]]},Evaluate@OptionValue[FSubPopOptions ],PlotRange->All,PlotStyle->OptionValue[FSubPopStyle]
];
Show[pldat,plsubpop,plfit,FilterRules[{opts}, Options[Graphics]],ImageSize->400,AspectRatio->1/2,Axes->False,Frame->True,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},FrameStyle-> Directive[Black,AbsoluteThickness[1]],FrameLabel->{"E","# (total: "<>ToString[Total@histodat[[All,2]]]<>")"}]
]
FPlotFRETFit[histodat:{{_?NumberQ,_?NumberQ}..},peaks:{Repeated["G"|"L"]},fitresult_,opts:OptionsPattern[]]:=Module[{barwidth},
barwidth=histodat[[2,1]]-histodat[[1,1]];FPlotFRETFit[Map[Append[#,barwidth]&,histodat],peaks,fitresult,opts]
]



FPlotFRETFit[histodat:{{{_?NumberQ,_?NumberQ,___}..}..},peaks:{Repeated["G"|"L"]},fitresult_,opts:OptionsPattern[]]:=
Module[{rule,fitresulti},
Table[FPlotFRETFit[histodat[[i]],peaks,fitresult/.p_Symbol[i,j_Integer]->p[j],opts],{i,Length[histodat]}]
]


Options[FFitFretHistogram]={FConstraints->None,FFixParams->{}}~Join~Options[NonlinearModelFit]~Join~ Options[FPlotFRETFit]~Join~ Options[FParamHisto];

FFitFretHistogram[histodat:{{_?NumberQ,_?NumberQ,_?NumberQ}..}|{{_?NumberQ,_?NumberQ}..},peaks:{Repeated["G"|"L"]},guess:{Repeated[_[_]|{_[_],_?NumberQ}]},opts:OptionsPattern[]]:=Module[{dat,model,fixparams,unfixedguess,nmf,fitresult,subpopplstyle},
dat=histodat[[All,1;;2]];
fixparams=OptionValue[FFixParams];
model=Total[Through[(FMakeFRETPeakModel[peaks][[1]]/.fixparams)[e]]];If[OptionValue[FConstraints]=!=None,model={model,OptionValue[FConstraints]}];unfixedguess=Select[guess/.fixparams,(!NumberQ[#[[1]]] )&];nmf=NonlinearModelFit[dat,model,unfixedguess,e,FilterRules[{opts}, Options[NonlinearModelFit]]];fitresult=nmf["BestFitParameters"]~Join~fixparams;fitresult=fitresult/.(Ampl[i_]->x_):>(Ampl[i]->Abs[x]);{fitresult,FPlotFRETFit[histodat,peaks,fitresult,FilterRules[{opts}, Options[FPlotFRETFit]]],nmf}
]

FFitFretHistogram[histodat:{{_?NumberQ,_?NumberQ,___}..}|{{{_?NumberQ,_?NumberQ,___}..}..},peaks_,peakposguess:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]},opts:OptionsPattern[]]:=FFitFretHistogram[histodat,peaks,FFindGuess[histodat,peaks,peakposguess],opts]

FFitFretHistogram[Erange:{_?NumberQ,_?NumberQ,_?NumberQ},etc__,opts:OptionsPattern[]]:=FFitFretHistogram[FParamHisto["E",Erange,FOutput->FData,FilterRules[{opts}, Options[FParamHisto]]],etc,opts]


FFitFretHistogram[expr_][Erange:{_?NumberQ,_?NumberQ,_?NumberQ},etc__,opts:OptionsPattern[]]:=FFitFretHistogram[FParamHisto[expr,Erange,FOutput->FData,FilterRules[{opts}, Options[FParamHisto]]],etc,FrameLabel->{ToString[expr],"Events"},opts]


FFRETPeakIntegrate[peaks:{Repeated["G"|"L"]},fretfitresult_,{E1_?NumberQ,E2_?NumberQ}]:=Module[{globparams,numberofmodels,models},globparams=Cases[fretfitresult,HoldPattern[_Symbol[_Integer]-> _]][[All,1]];numberofmodels=Max@@Cases[fretfitresult,HoldPattern[_Symbol[_Integer,_Integer]-> _]][[All,1,1]];If[numberofmodels>0,
(
models=FMakeFRETPeakModel[peaks,numberofmodels,globparams][[1]]/.fretfitresult;
Map[NIntegrate[Through[#[e]],{e,E1,E2}]&,models]
)
,NIntegrate[Through[(FMakeFRETPeakModel[peaks][[1]]/.fretfitresult)[e]],{e,E1,E2}]
]
]



FFitFretHistogram[histodat:{{{_?NumberQ,_?NumberQ,___}..}..},peaks:{Repeated["G"|"L"]},guess:{Repeated[_[__]|{_[__],_?NumberQ}]},opts:OptionsPattern[]]:=Module[{dat,model,fixparams,unfixedguess,nmf,fitresult,subpopplstyle,globparams,e},
dat=histodat[[All,All,1;;2]];globparams=Cases[guess,_Symbol[_Integer]|{_Symbol[_Integer],_?NumberQ}];globparams=Map[If[MatchQ[#,_Symbol[_Integer]],#,#[[1]]]&,globparams];fixparams=OptionValue[FFixParams];model=If[globparams=={},
FMakeFRETPeakModel[peaks,Length[dat]][[1]],
FMakeFRETPeakModel[peaks,Length[dat],globparams][[1]]
]/.fixparams;model=Map[Total@Through[#[e]]&,model];unfixedguess=Select[guess/.fixparams,(!NumberQ[#[[1]]] )&];nmf=If[OptionValue[FConstraints]=!=None,FNonlinearModelGlobalFit[dat,model,OptionValue[FConstraints],unfixedguess,{e},FilterRules[{opts}, Options[FindFit]]],FNonlinearModelGlobalFit[dat,model,unfixedguess,{e},FilterRules[{opts}, Options[FindFit]]]];fitresult=nmf["BestFitParameters"]~Join~fixparams;fitresult=fitresult/.(Ampl[j_][i_]->x_):>(Ampl[j][i]->Abs[x])/.(Ampl[i_]->x_):>(Ampl[i]->Abs[x]);{fitresult,FPlotFRETFit[histodat,peaks,fitresult,FilterRules[{opts}, Options[FPlotFRETFit]]],nmf}
]

FFitFretHistogram[histodat:{{{_?NumberQ,_?NumberQ,___}..}..},peaks:{Repeated["G"|"L"]},globalparams:{_Symbol[_Integer]..},peakposguess:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]},opts:OptionsPattern[]]:=FFitFretHistogram[histodat,peaks,FFindGuess[histodat,peaks,globalparams,peakposguess],opts]



Options[FDetermineShotNoiseWidths]={}~Join~Options[FFitFretHistogram];
FDetermineShotNoiseWidths[Erange:{_?NumberQ,_?NumberQ,_?NumberQ},peaks:{Repeated["G"|"L"]},peakposguess:{Repeated[_?NumberQ|{_?NumberQ,_?NumberQ}]},opts:OptionsPattern[]]:=
Module[{proxhisto,proxfit,pA,pstate,aroutes,droutes,ntotlist,proute,proutelist,blrc,rcm,bg,blrc2,fit,fitrc,recoloredhisto,pl,ExcessWidth,nA,nD,func},

proxhisto=FParamHisto["ProximityRatio",Erange,FOutput->FData,FilterRules[{opts}, Options[FParamHisto]]];
proxfit=FFitFretHistogram[proxhisto,peaks,peakposguess,FilterRules[{opts}, Options[FFitFretHistogram]]];
pA=Table[Pos[i],{i,Length[peaks]}]/.proxfit[[1]];
pstate=FFRETPeakIntegrate[peaks,proxfit[[1]],{-0,1}];
pstate/=Total[pstate];
aroutes=Flatten[Position[FGetAcceptorRoutes[],1]];
droutes=Flatten[Position[FGetDonorRoutes[],1]];
nA=Round@FGetFromBurstList[Table["n"<>ToString[i],{i,aroutes}],FilterRules[{opts}, Options[FGetFromBurstList]]];(* eg. MT200 nA={{n1...},{n3...}  *)
nD=Round@FGetFromBurstList[Table["n"<>ToString[i],{i,droutes}],FilterRules[{opts}, Options[FGetFromBurstList]]];(* eg. MT200 nD={{n2...},{n4...}  *)
ntotlist=(Plus@@nA)+(Plus@@nD);
proute=Map[Flatten@{# Total/@nA/Total[Total/@nA],(1-#) Total/@nD/Total[Total/@nD]}&,pA];(* Total/@nA/Total[Total/@nA]=distribution of acceptor photons onto the acceptor detectors*)
proutelist=RandomChoice[pstate->proute,Length[nA[[1]]]];
blrc=MapThread[RandomVariate[MultinomialDistribution[#1,#2]]&,{ntotlist,proutelist}];
rcm=FGetRCM[][[aroutes~Join~droutes,aroutes~Join~droutes]];
bg=Map[FGetBackground[][[aroutes~Join~droutes]]*#&,FGetFromBurstList["BurstDuration",FilterRules[{opts}, Options[FGetFromBurstList]] ]];

blrc2=Map[rcm . #&,blrc-bg];

recoloredhisto=Histo[With[{na=Total/@blrc2[[All,1;;Length[aroutes]]],ntot=Total/@blrc2,\[Alpha]=FGetDirectAcceptorExcitation[]},N@((na-\[Alpha] ntot)/((1-\[Alpha])ntot))],Erange,FOutput->FData];
fitrc=FFitFretHistogram[recoloredhisto,peaks,peakposguess,ChartStyle->Directive[Opacity[0.5],LightGray],FFitCurveStyle->{Red,AbsoluteThickness[3]},FilterRules[{opts}, Options[FFitFretHistogram]]];
fit=FFitFretHistogram[Erange,peaks,peakposguess,FilterRules[{opts}, Options[FFitFretHistogram]]];
func[et_]:=Module[{x,y},Through[FMakeFRETPeakModel[peaks][[1]][et]]/.{Ampl->x,Pos->y}/.fitrc[[1]]/.{x->Ampl,y->Pos}/.fit[[1]]];
pl=Module[{x,y,et},
Show[fit[[2]],Plot[Evaluate[func[et]],{et,Erange[[1]],Erange[[2]]},PlotRange->All,PlotStyle->Red]]
];
ExcessWidth=(Abs[Table[Width[i],{i,Length[peaks]}]]/.fit[[1]])-(Abs[Table[Width[i],{i,Length[peaks]}]]/.fitrc[[1]]);
{"Original data"->fit,"Recolored data"->fitrc,"overlay"->pl,"ExcessWidths"->ExcessWidth}

]


FGaussian2D[A_,x0:{_,_},\[Sigma]:{_,_},\[Alpha]_][x:{_,_}]:=Module[{rot,B},
rot=RotationMatrix[\[Alpha]];
B=DiagonalMatrix[1/(2\[Sigma]^2)];
A Exp[-{rot . (x-x0)} . B . (rot . (x-x0))][[1]]
]


FGetEllipsoid[x0:{_,_},\[Sigma]:{_,_},\[Alpha]_]:=Module[{rot,B,elipsoid,pxy,pxz,pyz},
rot=RotationMatrix[\[Alpha]];
B=DiagonalMatrix[\[Sigma]^2];
elipsoid=Ellipsoid[x0,rot\[Transpose] . B . rot]
]


FMakePeakModel2D[peaknames_List]:=
{
Function[xy,Total@Table[FGaussian2D[amplitudepeak[i],{x0peak[i],y0peak[i]},{\[Sigma]xpeak[i],\[Sigma]ypeak[i]},anglepeak[i]][xy],{i,peaknames}]],Flatten@Table[{amplitudepeak[i],x0peak[i],y0peak[i],\[Sigma]xpeak[i],\[Sigma]ypeak[i],anglepeak[i]},{i,peaknames}]
}


FFitPeaks2DMakeGuess[data_,peaknames_,positionguess:{{_?NumericQ,_?NumericQ}..}]:=Module[{f,params},
f=Interpolation[Map[{#[[1;;2]],#[[3]]}&,data]];
params={peaknames,positionguess,Map[f[Sequence@@#]&,positionguess[[All,1;;2]]]};
Flatten[MapThread[{{amplitudepeak[#1],#3},{x0peak[#1],#2[[1]]},{y0peak[#1],#2[[2]]},{\[Sigma]xpeak[#1],0.1},{\[Sigma]ypeak[#1],0.1},{anglepeak[#1],0}}&,params],1]
]


Clear[FFitPeaks2D]
Options[FFitPeaks2D]=Join[{FConstraints->None,FFixParams->{}},Options[ListContourPlot],Options[NonlinearModelFit]];
FFitPeaks2D[data_,peaknames_List,guess_List,opts:OptionsPattern[]]:=Module[{modelf,model,var,x,y,fit,pl,ellipses,eslist,fixparams,unfixedguess,fitresult,labels},
{modelf,var}=FMakePeakModel2D[peaknames];
fixparams=OptionValue[FFixParams];
model[{x_,y_}]=modelf[{x,y}]/.fixparams;
unfixedguess=Select[guess/.fixparams,(!NumberQ[#[[1]]] )&];
fit=If[OptionValue[FConstraints]===None,
NonlinearModelFit[data,model[{x,y}],unfixedguess,{x,y},FilterRules[{opts}, Options[NonlinearModelFit]]],
NonlinearModelFit[data,{model[{x,y}],OptionValue[FConstraints]},unfixedguess,{x,y},FilterRules[{opts}, Options[NonlinearModelFit]]]
];
fitresult=fit["BestFitParameters"]~Join~fixparams;
pl=ListContourPlot[data,FilterRules[{opts}, Options[ListContourPlot]],ColorFunction->(If[#!=0,Hue[(0.75-.75#)],White]&),LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},PlotRange->Automatic,FrameStyle-> Directive[Black,AbsoluteThickness[0.8]],ImageSize-> 400,AspectRatio->1/GoldenRatio];
ellipses=FGetEllipsoid@@@Table[{{x0peak[i],y0peak[i]},{\[Sigma]xpeak[i],\[Sigma]ypeak[i]},anglepeak[i]},{i,peaknames}]/.fitresult;
eslist=Table[{x0peak[s],y0peak[s]}/.fitresult,{s,peaknames}];
labels=Table[Text[ToString[s],{x0peak[s],y0peak[s]+2Abs@\[Sigma]ypeak[s]},{0,-1}]/.fitresult,{s,peaknames}];
pl=Show[pl,Graphics[{{EdgeForm[{Thick,Red}],FaceForm[],ellipses},labels}]];
{eslist,pl,fitresult,fit}
]


FFitPeaks2D[data_,peaknames_List,positionguess:{{_?NumericQ,_?NumericQ}..},opts:OptionsPattern[]]:=FFitPeaks2D[data,peaknames,FFitPeaks2DMakeGuess[data,peaknames,positionguess],opts]


FBurstAsymmetry[{Emin_,Emax_,dE_},{Amin_,Amax_,dA_},sigma_?NumberQ]:=Module[{dat,outlyer,bc,xv,yv,xyz},
{dat,outlyer}=FPBurstAsymmetry[sigma];
{ListPlot[Select[{dat,outlyer},(Length[#]>0)&],Frame->True,Axes->False,PlotRange->{{Emin,Emax},{Amin,Amax}},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},ImageSize-> 400,PlotLabel->"Total="<>ToString[Length[dat]]<>"; Outlyer="<>ToString[Length[outlyer]],PlotStyle->{Blue,Red}],
Histo2D[dat,{Emin,Emax,dE},{Amin,Amax,dA},FOutput->FGraph],
Histo2D[outlyer,{Emin,Emax,dE},{Amin,Amax,dA},FOutput->FGraph]
}
]


FCutAsymmetricBursts[\[Sigma]_?NumberQ]:=FCutAsymmetricBursts[N[\[Sigma]]]


FPIEBurstAsymmetry[{Emin_,Emax_,dE_},{Amin_,Amax_,dA_},sigma_?NumberQ]:=Module[{dat,outlyer,bc,xv,yv,xyz},
{dat,outlyer}=FPPIEBurstAsymmetry[sigma];
{ListPlot[Select[{dat,outlyer},(Length[#]>0)&],Frame->True,Axes->False,PlotRange->{{Emin,Emax},{Amin,Amax}},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},ImageSize-> 400,PlotLabel->"Total="<>ToString[Length[dat]]<>"; Outlyer="<>ToString[Length[outlyer]],PlotStyle->{Blue,Red}],
Histo2D[dat,{Emin,Emax,dE},{Amin,Amax,dA},FOutput->FGraph],
Histo2D[outlyer,{Emin,Emax,dE},{Amin,Amax,dA},FOutput->FGraph]
}
]


FPIECutAsymmetricBursts[\[Sigma]_?NumberQ]:=FPIECutAsymmetricBursts[N[\[Sigma]]]


FCorrelTransformRawData[correldat_]:={Drop[CorrelikonTauBins*CorrelikonTimeUnitSec/.correldat,-1],CorrelikonG12/.correldat}\[Transpose]


FTimeCorrelate[tau:{_?NumberQ..},t1:{_?NumberQ..},t2:{_?NumberQ..}]:=FCorrelTransformRawData@FCorrelateStr[N[tau],N[t1],N[t2]]


Options[FTimeCorrelateWeighted]={FNumberOfStepsInCascade->10,FOutput->FData}~Join~ Options[ListPlot];
FTimeCorrelateWeighted[t1:{{_Integer,_?NumericQ}..},t2:{{_Integer,_?NumericQ}..},taumin_?NumericQ, taumax_?NumericQ, timeunit_?NumericQ,opts:OptionsPattern[]]:=
Module[{tau1,tau2,B=10,dat},
tau1=Max[1,Round[taumin/timeunit]];
tau2=Max[1,Round[taumax/timeunit]];
B=OptionValue[FNumberOfStepsInCascade];
dat=FPCorrelateWeighted[tau1,tau2,B,N@timeunit,t1[[All,1]],t2[[All,1]],N@t1[[All,2]],N@t2[[All,2]]];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@FCorrelTransformRawData@dat;
dat[[All,1]]=Log[10.,dat[[All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@FCorrelTransformRawData@dat
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]


Options[FFCS]={FPhotonData->All,FOutput->FData, FUseMicrotime->False}~Join~ Options[ListPlot];


FFCS[tau:{_?NumberQ..},route1:FRouteList,route2:FRouteList,tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=
Module[{mode=0,dat,usemicrotime},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2
,True, Return[$Failed]
];
usemicrotime=If[OptionValue[FUseMicrotime]===True,1,0];dat=FFCSStr[N[tstart],N[tstop],N[tau],FRouteListToByte[route1],FRouteListToByte[route2],usemicrotime,mode];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@FCorrelTransformRawData@dat;
dat[[All,1]]=Log[10.,dat[[All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@FCorrelTransformRawData@dat
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]
FFCS[tau:{_?NumberQ..},route1:FRouteList,route2:FRouteList,opts:OptionsPattern[]]:=FFCS[tau,route1,route2,-1.,-1.,opts]

FFCS[tau:{_?NumberQ..},route1:FRouteList,route2:FRouteList,{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{mode=0,dat,usemicrotime},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
usemicrotime=If[OptionValue[FUseMicrotime]===True,1,0];dat=FFCSStr[N[tstart],N[tstop],N[tau],FRouteListToByte[route1],FRouteListToByte[route2],{ch11,ch12}-1,{ch21,ch22}-1,usemicrotime,mode];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@FCorrelTransformRawData@dat;
dat[[All,1]]=Log[10.,dat[[All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@FCorrelTransformRawData@dat
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]
FFCS[tau:{_?NumberQ..},route1:FRouteList,route2:FRouteList,{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},opts:OptionsPattern[]]:=FFCS[tau,route1,route2,{ch11 ,ch12},{ch21 ,ch22},-1.,-1.,opts]

FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,route1:FRouteList,route2:FRouteList,tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=FFCS[Table[10^logt,{logt,logtaumin,logtaumax,dlogtau}],route1,route2,tstart,tstop,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,route1:FRouteList,route2:FRouteList,opts:OptionsPattern[]]:=
FFCS[logtaumin,logtaumax,dlogtau,route1,route2,-1.,-1.,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,route1:FRouteList,route2:FRouteList,{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=FFCS[Table[10^logt,{logt,logtaumin,logtaumax,dlogtau}],route1,route2,{ch11,ch12},{ch21,ch22},tstart,tstop,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,route1:FRouteList,route2:FRouteList,{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},opts:OptionsPattern[]]:=FFCS[logtaumin,logtaumax,dlogtau,route1,route2,{ch11,ch12},{ch21,ch22},-1.,-1,opts]



FFCS[tau:{_?NumberQ..},routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=
Module[{mode=0,dat,usemicrotime},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
usemicrotime=If[OptionValue[FUseMicrotime]===True,1,0];
dat=FFCSParallelStr[N[tstart],N[tstop],N[tau],Map[FRouteListToByte,Flatten[routepairs,1]],usemicrotime,mode];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@Map[FCorrelTransformRawData,dat];
dat[[All,All,1]]=Log[10.,dat[[All,All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@Map[FCorrelTransformRawData,dat]
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]
FFCS[tau:{_?NumberQ..},routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},opts:OptionsPattern[]]:=FFCS[tau,routepairs,-1.,-1.,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=FFCS[Table[10^logt,{logt,logtaumin,logtaumax,dlogtau}],routepairs,tstart,tstop,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},opts:OptionsPattern[]]:=
FFCS[logtaumin,logtaumax,dlogtau,routepairs,-1.,-1.,opts]

FFCS[tau:{_?NumberQ..},routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{mode=0,dat,usemicrotime},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
usemicrotime=If[OptionValue[FUseMicrotime]===True,1,0];dat=FFCSParallelStr[N[tstart],N[tstop],N[tau],Map[FRouteListToByte,Flatten[routepairs,1]],{ch11,ch12}-1,{ch21,ch22}-1,usemicrotime,mode];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@Map[FCorrelTransformRawData,dat];
dat[[All,All,1]]=Log[10.,dat[[All,All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@Map[FCorrelTransformRawData,dat]
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]
FFCS[tau:{_?NumberQ..},routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{ch11_?FValidChannelQ ,ch12_?FValidChannelQ},{ch21_?FValidChannelQ ,ch22_?FValidChannelQ},opts:OptionsPattern[]]:=FFCS[tau,routepairs,{ch11 ,ch12},{ch21 ,ch22},-1.,-1.,opts]

FFCS[tau:{_?NumberQ..},params:{{{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}},{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}}}..},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{params2,mode=0,dat,usemicrotime},
params2=Map[{FRouteListToByte[#[[1,1]]],FRouteListToByte[#[[2,1]]],Sequence@@(#[[1,2]]-1),Sequence@@(#[[2,2]]-1)}&,params];
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
usemicrotime=If[OptionValue[FUseMicrotime]===True,1,0];dat=FFCSWithChannelConstraintsParallelStr[N[tstart],N[tstop],N[tau],usemicrotime,mode,params2];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@Map[FCorrelTransformRawData,dat];
dat[[All,All,1]]=Log[10.,dat[[All,All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@Map[FCorrelTransformRawData,dat]
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]
FFCS[tau:{_?NumberQ..},params:{{{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}},{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}}}..},opts:OptionsPattern[]]:=FFCS[tau,params,-1.,-1.opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,params:{{{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}},{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}}}..},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=FFCS[Table[10^logt,{logt,logtaumin,logtaumax,dlogtau}],params,tstart,tstop,opts]
FFCS[logtaumin_?NumberQ,logtaumax_?NumberQ,dlogtau_?NumberQ,params:{{{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}},{_?(MatchQ[#,FRouteList]&),{_?FValidChannelQ ,_?FValidChannelQ}}}..},opts:OptionsPattern[]]:=FFCS[logtaumin,logtaumax,dlogtau,params,-1.,-1.,opts]



Options[FFCSW]={FPhotonData->All,FNumberOfStepsInCascade->10,FOutput->FData, FUseMicrotime->False}~Join~ Options[ListPlot];
FFCSW[logtaumin_?NumberQ,logtaumax_?NumberQ,{route1:FRouteList,weights1:{_?NumberQ..}},{route2:FRouteList,weights2:{_?NumberQ..}},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{mode=0,B=10,dat},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
B=OptionValue[FNumberOfStepsInCascade];dat=FFCSWeightedStr[N[tstart],N[tstop],N[10^logtaumin],N[10^logtaumax],B,FRouteListToByte[route1],FRouteListToByte[route2],N@weights1,N@weights2,mode];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@FCorrelTransformRawData@dat;
dat[[All,1]]=Log[10.,dat[[All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@FCorrelTransformRawData@dat
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]

FFCSW[logtaumin_?NumberQ,logtaumax_?NumberQ,{route1:FRouteList,weights1:{Rule[_Integer,{_?NumberQ..}]..}},{route2:FRouteList,weights2:{Rule[_Integer,{_?NumberQ..}]..}},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{mode=0,B=10,dat,w1,w2},
Which[
OptionValue[FPhotonData]===All,mode=0,
     (*OptionValue[FPhotonData]===FBursts,mode=1,*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
B=OptionValue[FNumberOfStepsInCascade];
w1=Range[FNumberOfRoutes]/.weights1;
w1=Replace[w1,{_Integer->ConstantArray[0.,FMaxChannel],x_List:>PadRight[x,FMaxChannel,0.]},1];
w2=Range[FNumberOfRoutes]/.weights2;
w2=Replace[w2,{_Integer->ConstantArray[0.,FMaxChannel],x_List:>PadRight[x,FMaxChannel,0.]},1];
dat=FFCSWeightedStr2[N[tstart],N[tstop],N[10^logtaumin],N[10^logtaumax],B,FRouteListToByte[route1],FRouteListToByte[route2],mode, w1, w2];
Which[
OptionValue[FOutput] === FGraph,
(
dat=N@FCorrelTransformRawData@dat;
dat[[All,1]]=Log[10.,dat[[All,1]]];ListPlot[dat,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> Medium,FontWeight-> Bold}]
),
OptionValue[FOutput]===FData,
(
N@FCorrelTransformRawData@dat
),
OptionValue[FOutput]===FRawData,
(
dat
)
]
]

FFCSW[logtaumin_?NumberQ,logtaumax_?NumberQ,{route1:FRouteList,weights1_},{route2:FRouteList,weights2_},opts:OptionsPattern[]]:=FFCSW[logtaumin,logtaumax,{route1,weights1},{route2,weights2},-1,-1,opts]

FFCSW[logtaumin_?NumberQ,logtaumax_?NumberQ,route1:FRouteList,route2:FRouteList,tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=FFCSW[logtaumin,logtaumax,{route1,ConstantArray[1,FMaxChannel]},{route2,ConstantArray[1,FMaxChannel]},tstart,tstop,opts]

FFCSW[logtaumin_?NumberQ,logtaumax_?NumberQ,route1:FRouteList,route2:FRouteList,opts:OptionsPattern[]]:=FFCSW[logtaumin,logtaumax,route1,route2,-1,-1,opts]


FFCSModel[{\[Tau]D_,expdecays:{{_,_}...}},a_][t_]:=  Fold[Times,1,Map[1+#[[1]]Exp[-t/#[[2]]]&,expdecays]]/((1+t/\[Tau]D)(1+a^-2 t/\[Tau]D)^(1/2))
FFCSModel[species:{{_,_,_,_,{{_,_}...}}..},a_,bg1_,bg2_][t_]:=Module[{n,Q1,Q2,g},
n=species[[All,1]];
Q1=species[[All,2]];
Q2=species[[All,3]];
g=species[[All,4;;5]];
1+Total[n Q1 Q2 Map[FFCSModel[#,a][t]&,g]] /((Total[n Q1 ]+bg1)(Total[n Q2 ]+bg2))
]
FFCSModel[species:{_,_,_,_,{{_,_}...}},a_,bg1_,bg2_][t_]:=FFCSModel[{species},a,bg1,bg2][t]


F2DFLCSLifeTimeChannelMap[tstart_?NumericQ,tstop_?NumericQ,tau:{_?NumericQ..},route1:FRouteList,route2:FRouteList,channelranges:{{_?FValidChannelQ ,_?FValidChannelQ}..}]:=
F2DFLCSLifeTimeChannelMapP[N@tstart,N@tstop,N@tau,FRouteListToByte[route1],FRouteListToByte[route2],Flatten@channelranges,0]


Options[FnsFCS]={FPhotonData->All, FOutput->FData};
FnsFCS[route1:FRouteList,route2:FRouteList,{taumin_?NumberQ,taumx_?NumberQ,dtau_?NumberQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{cdat,mode=0},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
cdat=FBunchStr[N[tstart],N[tstop],FRouteListToByte[route1],FRouteListToByte[route2],N[taumin],N[taumx],N[dtau],mode];
Which[
OptionValue[FOutput]===FData,
(
cdat=FCorrelTransformRawData[cdat];cdat[[All,1]]/=10.^-6;cdat[[All,1]]+=taumin;
cdat
),
OptionValue[FOutput]===FRawData,
cdat
]
]
FnsFCS[route1:FRouteList,route2:FRouteList,{taumin_?NumberQ,taumx_?NumberQ,dtau_?NumberQ},opts:OptionsPattern[]]:=FnsFCS[route1,route2,{taumin,taumx,dtau},-1.,-1.,opts]


FnsFCS[routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{taumin_?NumberQ,taumx_?NumberQ,dtau_?NumberQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[{cdat,mode=0},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)OptionValue[FPhotonData]===FSelectedBursts,mode=2,True, Return[$Failed]
];
cdat=FBunchParallelStr[N[tstart],N[tstop],Map[FRouteListToByte,Flatten[routepairs,1]],N[taumin],N[taumx],N[dtau],mode];
Which[
OptionValue[FOutput]===FData,(cdat=Map[FCorrelTransformRawData,cdat];cdat[[All,All,1]]/=10.^-6;cdat[[All,All,1]]+=taumin;
cdat
),
OptionValue[FOutput]===FRawData,
cdat
]
]
FnsFCS[routepairs:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{taumin_?NumberQ,taumx_?NumberQ,dtau_?NumberQ},opts:OptionsPattern[]]:=FnsFCS[routepairs,{taumin,taumx,dtau},-1.,-1.,opts]


FBunch:=FnsFCS;


FCorrelSecondOrderTransformRawData[cdat_]:=Module[{dat,t1,t2},
dat=CorrelikonG123/.cdat;
t1=Drop[CorrelikonTauBins1 CorrelikonTimeUnitSec 10^6/.cdat,1];
t2=Drop[CorrelikonTauBins2 CorrelikonTimeUnitSec 10^6/.cdat,1];
MapThread[Append,{Outer[List,t1,t2],dat},2]]


Options[FnsFCSSecondOrder]={FPhotonData->All};
FnsFCSSecondOrder[route1:FRouteList,route2:FRouteList,route3:FRouteList,{tau1min_?NumberQ,tau1mx_?NumberQ,dtau1_?NumberQ},{tau2min_?NumberQ,tau2mx_?NumberQ,dtau2_?NumberQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=
Module[{cdat,mode=0},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];

cdat=FBunchSecondOrderStr[N[tstart],N[tstop],FRouteListToByte[route1],FRouteListToByte[route2],FRouteListToByte[route3],N[tau1min],N[tau1mx],N[dtau1],N[tau2min],N[tau2mx],N[dtau2],mode];
FCorrelSecondOrderTransformRawData[cdat]
]
FnsFCSSecondOrder[route1:FRouteList,route2:FRouteList,route3:FRouteList,{tau1min_?NumberQ,tau1mx_?NumberQ,dtau1_?NumberQ},{tau2min_?NumberQ,tau2mx_?NumberQ,dtau2_?NumberQ},opts:OptionsPattern[]]:=FnsFCSSecondOrder[route1,route2,route3,{tau1min,tau1mx,dtau1},{tau2min,tau2mx,dtau2},-1.,-1.,opts]


FnsFCSSecondOrder[routetriples:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{tau1min_?NumberQ,tau1mx_?NumberQ,dtau1_?NumberQ},{tau2min_?NumberQ,tau2mx_?NumberQ,dtau2_?NumberQ},tstart_?NumberQ,tstop_?NumberQ,opts:OptionsPattern[]]:=Module[
{cdat,dat,t1,t2,mode=0},
Which[
OptionValue[FPhotonData]===All,mode=0,
(*OptionValue[FPhotonData]===FBursts,mode=1,*)
(*"OptionValue[FPhotonData]===FNonBursts,mode=2,"*)
OptionValue[FPhotonData]===FSelectedBursts,mode=2,
True, Return[$Failed]
];
cdat=FBunchSecondOrderParallelStr[N[tstart],N[tstop],Map[FRouteListToByte,Flatten[routetriples,1]],N[tau1min],N[tau1mx],N[dtau1],N[tau2min],N[tau2mx],N[dtau2],mode]
Map[FCorrelSecondOrderTransformRawData,cdat]
]
FnsFCSSecondOrder[routetriples:{{_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&),_?(MatchQ[#,FRouteList]&)}..},{tau1min_?NumberQ,tau1mx_?NumberQ,dtau1_?NumberQ},{tau2min_?NumberQ,tau2mx_?NumberQ,dtau2_?NumberQ},opts:OptionsPattern[]]:=FnsFCSSecondOrder[routetriples,{tau1min,tau1mx,dtau1},{tau2min,tau2mx,dtau2},-1.,-1.,opts]


FCorrelateBinnedData[dat1_List,dat2_List,n_Integer]:=Module[{max,ab},
If[Length[dat1]!=Length[dat2],$Failed,(
max=Min[n+1,Length[dat1]];
ab=ListCorrelate[dat1,dat2,{1,Length[dat1]-max+1},0];
ab/=Reverse[Accumulate[dat1][[-max;;]]Accumulate[Reverse[dat2]][[-max;;]] ];
Rest[ab*Reverse[Range[Length[dat1]-max+1,Length[dat2]]]])
]
]


Options[FSameMoleculeProbability]={FOutput->FGraph}~Join~Options[ListPlot]~Join~Options[ListLogLinearPlot];

FSameMoleculeProbability[{taumin_,taumax_,dtau_},{bursttimes1:{_?NumberQ..},bursttimes2:{_?NumberQ..}},opts:OptionsPattern[]]:=Module[{tau,PSdata},
tau=Range[taumin,taumax,dtau];
PSdata=Map[{#[[1]],1-1/#[[2]]}&,FTimeCorrelate[tau,bursttimes1,bursttimes2]];
If[OptionValue[FOutput]===FGraph,
ListPlot[PSdata,FilterRules[{opts}, Options[ListPlot]],PlotRange->All,Frame->True,Axes->False,FrameLabel->{"\[Tau](ms)", "\!\(\*SubscriptBox[\(p\), \(Same\)]\)"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold}],
PSdata]
]
FSameMoleculeProbability[{taumin_,taumax_,dtau_},bursttimes:{_?NumberQ..},opts:OptionsPattern[]]:=FSameMoleculeProbability[{taumin,taumax,dtau},{bursttimes,bursttimes},opts];
FSameMoleculeProbability[{taumin_,taumax_,dtau_},opts:OptionsPattern[]]:=Module[{bursttimes},
bursttimes=FGetFromBurstList[1000.Mean[{"EndTime","StartTime"}]];
FSameMoleculeProbability[{taumin,taumax,dtau},bursttimes,opts]
]




FSameMoleculeProbability[{MinimalTauBin_?NumberQ,taumax_?NumberQ},{bursttimes1:{_?NumberQ..},bursttimes2:{_?NumberQ..}},opts:OptionsPattern[]]:=Module[{tau,\[CapitalDelta],k,correldat,PSdata,st},
st=0;
tau={};
k=0;
\[CapitalDelta]=MinimalTauBin;
If[\[CapitalDelta]<=0,\[CapitalDelta]=1.];
While[st<taumax,
AppendTo[tau,Table[st+= \[CapitalDelta] 2^k,{n,1,10}]];
k++;
];
tau=Flatten[tau];
tau=Select[tau,#<=taumax&];
correldat=FTimeCorrelate[tau,bursttimes1,bursttimes2];
PSdata=Map[{#[[1]],1-1/#[[2]]}&,correldat];
If[OptionValue[FOutput]===FGraph,
ListLogLinearPlot[PSdata,FilterRules[{opts}, Options[ListLogLinearPlot]],PlotRange->All,Frame->True,Axes->False,FrameLabel->{"\[Tau](ms)", "\!\(\*SubscriptBox[\(p\), \(Same\)]\)"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold}],
PSdata]
]
FSameMoleculeProbability[{MinimalTauBin_?NumberQ,taumax_?NumberQ},bursttimes:{_?NumberQ..},opts:OptionsPattern[]]:=FSameMoleculeProbability[{MinimalTauBin,taumax},{bursttimes,bursttimes},opts]




(* OLD 
FRecurrenceList[burstlist_List,{E1_?NumberQ,E2_?NumberQ},{t1_?NumberQ,t2_?NumberQ},opts___]:=Module[{pos,f},
pos=Flatten[Position[burstlist,{_?((E1<#<E2)&),t_,___}]];
f[position_]:= Module[{j=position+1,elist={},t0=burstlist[[position,2]]},
While[j<=Length[burstlist]&&burstlist[[j,2]]-t0<t1,j++];
While[j<=Length[burstlist]&&burstlist[[j,2]]-t0<=t2,
(AppendTo[elist,{burstlist[[position,1]],burstlist[[j,1]],burstlist[[j,2]]-t0,{position,j}}];
j++;)];
elist];
Flatten[Map[f,pos],1]
]
*)

FRecurrenceList[burstlist_List,{E1_?NumberQ,E2_?NumberQ},{t1_?NumberQ,t2_?NumberQ},opts___]:=Module[{pos,f},
pos=Flatten[Position[burstlist,{_?((E1<#<E2)&),t_,___}]];
f[position_]:= Module[{j=position+1,elist={},t0=burstlist[[position,2]]},
While[j<=Length[burstlist]&&burstlist[[j,2]]-t0<t1,j++];
elist=Last@Reap[
While[j<=Length[burstlist]&&burstlist[[j,2]]-t0<=t2,
(Sow[{burstlist[[position,1]],burstlist[[j,1]],burstlist[[j,2]]-t0,{position,j}}];
j++;)]
];
elist];
Flatten[Map[f,pos],2]
]


Options[FRecurrenceList]={FCheckTimeMaxB2Count->100};
(*FRecurrenceList[burstlist_List,E1select_,dtselect_,opts:OptionsPattern[]]:=Module[{pos,f,maxb2},
pos=Flatten[Position[burstlist,{_?E1select,t_}]];
If[OptionValue[FCheckTimeMaxB2Count]===All,maxb2=Length[burstlist],maxb2=OptionValue[FCheckTimeMaxB2Count],maxb2=Length[burstlist]];
f[position_]:= Module[{elist={},t0=burstlist[[position,2]]},
Do[(If[dtselect[burstlist[[j,2]]-t0],AppendTo[elist,{burstlist[[position,1]],burstlist[[j,1]],burstlist[[j,2]]-t0,{position,j}}]];)
,{j,position+1,Min[position+maxb2,Length[burstlist]]}];
elist];
Flatten[Map[f,pos],1]
]
*)

FRecurrenceList[burstlist_List,E1select_,dtselect_,opts:OptionsPattern[]]:=Module[{pos,f,maxb2},
pos=Flatten[Position[burstlist,{_?E1select,t_}]];
If[OptionValue[FCheckTimeMaxB2Count]===All,maxb2=Length[burstlist],maxb2=OptionValue[FCheckTimeMaxB2Count],maxb2=Length[burstlist]];
f[position_]:= Module[{elist={},t0=burstlist[[position,2]]},
elist=First@Last@Reap[
Do[(If[dtselect[burstlist[[j,2]]-t0],Sow[{burstlist[[position,1]],burstlist[[j,1]],burstlist[[j,2]]-t0,{position,j}}]];)
,{j,position+1,Min[position+maxb2,Length[burstlist]]}];
];
elist];
Flatten[Map[f,pos],1]
]


FRecurrenceHisto[burstlist_List,{E1_?NumberQ,E2_?NumberQ},{t1_?NumberQ,t2_?NumberQ},historange:{_?NumberQ,_?NumberQ,_?NumberQ},opts:OptionsPattern[]]:=Module[{recdat},
recdat=FRecurrenceList[burstlist,{E1,E2},{t1,t2},FilterRules[{opts}, Options[FRecurrenceList]]][[All,2]];
Histo[recdat,historange,FilterRules[{opts}, Options[Histo]],PlotRange->All]
]


FRecurrenceHisto[burstlist_List,E1select_,dtselect_,historange:{_?NumberQ,_?NumberQ,_?NumberQ},opts:OptionsPattern[]]:=Module[{recdat},
recdat=FRecurrenceList[burstlist,E1select,dtselect,FilterRules[{opts}, Options[FRecurrenceList]]][[All,2]];
Histo[recdat,historange,FilterRules[{opts}, Options[Histo]],PlotRange->All]
]


(*Plot Recurrence Histogram, Complete Histogram*)
Options[FRecurrenceHistoN]={LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12(*,FontWeight-> Bold*)},FrameStyle->Directive[Black,AbsoluteThickness[1]],ChartStyle->{Directive[Opacity[0.5,Lighter[Gray,0.9]],EdgeForm[{AbsoluteThickness[1],Lighter[Gray,0.4]}]],Directive[Opacity[0.2,Darker[Blue,0.2]],EdgeForm[{AbsoluteThickness[1],Opacity[0.5,Darker[Blue,0.2]]}]]},FrameTicksStyle->{{FontFamily-> "Helvetica",FontSize-> 12(*,FontWeight-> Bold*)},Directive[Black,AbsoluteThickness[1]]},Frame->True,Axes->False,AspectRatio->0.6,ImageSize->500}(*~Join~Options[FPlotHisto]*);

FRecurrenceHistoN[burstlist_List,{E1_?NumberQ,E2_?NumberQ},{t1_?NumberQ,t2_?NumberQ},historange:{_?NumberQ,_?NumberQ,_?NumberQ},opts:OptionsPattern[]]:=Module[{recdat,HistFull,MaxFull,HistRec,MaxRec,NumRec,ticks,texttemp,PlotRec},
PlotRec:=Module[{SpacingToHist,SpacingToFrame,Facto,y1,y2,yRange,LineThickness=1.5},
SpacingToHist=0.0;SpacingToFrame=0.04;Facto=300;
y1=-LineThickness/Facto-SpacingToHist;y2=1.1+LineThickness/Facto+SpacingToHist;yRange={y1-SpacingToFrame,y2+3 SpacingToFrame};
{Red,AbsoluteThickness[LineThickness],Line[{{E1,y1},{E2,y1},{E2,y2},{E1,y2},{E1,y1}}]}];
recdat=FRecurrenceList[burstlist,{E1,E2},{t1,t2},opts][[All,2]];
HistRec=Histo[recdat,historange,opts,FOutput->Data];NumRec=Total[HistRec[[All,2]]];
MaxRec=Max[HistRec[[All,2]]];
If[MaxRec!=0,HistRec[[All,2]]/=MaxRec];
HistFull=Histo[burstlist[[All,1]],historange,FOutput->Data];
MaxFull=Max[HistFull[[All,2]]];
If[MaxFull!=0,HistFull[[All,2]]/=MaxFull];

texttemp="\!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)=("<>ToString[t1]<>","<>ToString[t2]<>") ms";
FPlotHisto[{HistFull,HistRec},Evaluate[FilterRules[{opts}, Options[FPlotHisto]]],FilterRules[Options[FRecurrenceHistoN], Options[FPlotHisto]],FrameLabel->{Style["E",Italic],Style["\[Times] "<>ToString[MaxRec],RGBColor[0.360784, 0.611765, 0.921569]]},
PlotLabel->texttemp,Epilog->{PlotRec},PlotRange->{-0.02,1.15}]
]


FRecurrenceHisto2D[burstlist_List,{t1_?NumberQ,t2_?NumberQ},historange:{_?NumberQ,_?NumberQ,_?NumberQ},opts:OptionsPattern[]]:=Module[{recdat,sbl},
sbl=FRecurrenceList[burstlist,{historange[[1]],historange[[2]]},{t1,t2},FilterRules[{opts}, Options[FRecurrenceList]]];
Histo2D[sbl[[All,1;;2]],historange,historange,FilterRules[{opts}, Options[Histo2D]],FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(1\)]\)","\!\(\*SubscriptBox[\(E\), \(2\)]\)",Style["\!\(\*
StyleBox[\"T\",\nFontSlant->\"Italic\"]\)=("<> ToString[t1]<>","<>ToString[t2]<>") ms,  #"<>ToString[Length[sbl]],Black]},ClippingStyle->{White,RGBColor[0,0,0.5]},PlotRange->{All,All,All},ContourStyle->Gray,InterpolationOrder->1,Contours->12,ColorFunction->(RGBColor[0.3 #/2,0 #/2,0.66,0.8(#/1 1+0.1) ]&),AspectRatio->Automatic,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 16},FrameStyle-> AbsoluteThickness[2],FrameTicksStyle->AbsoluteThickness[2]]
]


FRecurrenceHisto2D[burstlist_List,dtselect_,historange:{_?NumberQ,_?NumberQ,_?NumberQ},opts:OptionsPattern[]]:=Module[{recdat,sbl},
sbl=FRecurrenceList[burstlist,(historange[[1]]<#<historange[[2]])&,dtselect,FilterRules[{opts}, Options[FRecurrenceList]]];
Histo2D[sbl[[All,1;;2]],historange,historange,FilterRules[{opts}, Options[Histo2D]],FrameLabel->{"\!\(\*SubscriptBox[\(E\), \(1\)]\)","\!\(\*SubscriptBox[\(E\), \(2\)]\)"},PlotLabel-> ToString[dtselect[\[CapitalDelta]t]]<>" ms",ContourStyle->Gray,BoundaryStyle->Gray,ClippingStyle->{White,RGBColor[0,0,0.5]},PlotRange->{All,All,All},InterpolationOrder->1,Contours->12,ColorFunction->(RGBColor[0.3 #/2,0 #/2,0.66,0.8(#/1 1+0.1) ]&),AspectRatio->Automatic]
]


(*
Clear[FFCSModel]
Options[FFCSModel]={FOutput->FGraph,F2fFCSLambdaex->.485,F2fFCSLambdaem->.515,F2fFCSpinhole->100.,F2fFCSmagnification->60}~Join~ Options[ListPlot];

(*Version where amplitudes are obtained internally.*)
FFCSModel[logtaus:{_?NumberQ..},diffs:{_?NumberQ..},velocities:{vy_?NumberQ,vz_?NumberQ},w0_?NumberQ,R0_?NumberQ,nrefractive_?NumberQ,opts:OptionsPattern[]]:=Module[{model,output,pl1,pl2},

model=FPGdiff[N@logtaus,N@diffs,N@w0,N@R0,N@vy,N@vz,N@OptionValue[F2fFCSLambdaex]/nrefractive,N@OptionValue[F2fFCSLambdaem]/nrefractive,N@OptionValue@F2fFCSpinhole,N@OptionValue@F2fFCSmagnification];
model
]
*)


FAExplambdat[A:{_?NumberQ..},lambda:{_?NumberQ..},times:{_?NumberQ..}]:=FPAExplambdat[N@A,N@lambda,N@times]

FExpkAbst[k_?NumberQ,times:{_?NumberQ..}]:=FPExpkAbst[N@k,N@times]
FOneMinusExpkAbst[k_?NumberQ,times:{_?NumberQ..}]:=FPOneMinusExpkAbst[N@k,N@times]


FV2expKtV1pss[K_,V1pss:{_?NumberQ..},TotV2:{_?NumberQ..},times:{_?NumberQ..}]:=FPV2expKtV1pss[N@Flatten@K,N@V1pss,N@TotV2,N@times]

FEigenSystem[Km_?(MatrixQ[#,NumberQ]&)]:=Module[{\[Lambda],U,Uinv},{\[Lambda],U,Uinv}=FPEigenSystem[N@Flatten[Km\[Transpose]],Length[Km]];Chop@{\[Lambda],U\[Transpose],Uinv\[Transpose]}]


Options[F2focusFCSExport]={FPrintPlot->True};


F2focusFCSExport[filename_String, logtaumin_, logtaumax_, dlogtau_, route1:FRouteList, route2:FRouteList, 
   {(ch11_)?FValidChannelQ, (ch12_)?FValidChannelQ}, {(ch21_)?FValidChannelQ, (ch22_)?FValidChannelQ}, 
   (tstart_)?NumberQ, (tstop_)?NumberQ,opts:OptionsPattern[]] := Module[{fcspl, correldat, logcorreldat, c11, c12, c21, c22}, 
   logcorreldat := ({Log[10, #1[[1]]], #1[[2]]} & ) /@ correldat; fcspl := ListPlot[logcorreldat, Joined -> True, PlotRange -> All, 
      Frame -> True, Axes -> False, FrameLabel -> {"log(\[Tau]/sec)", "G(\[Tau])"}, 
      LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 12, FontWeight -> Bold}]; 
    {c11, c22, c12, c21} = FFCS[logtaumin, logtaumax, dlogtau, {{{route1, {ch11, ch12}}, {route2, {ch11, ch12}}}, 
       {{route1, {ch21, ch22}}, {route2, {ch21, ch22}}}, {{route1, {ch11, ch12}}, {route2, {ch21, ch22}}}, 
       {{route2, {ch21, ch22}}, {route1, {ch11, ch12}}}}, tstart, tstop]; 
If[OptionValue[FPrintPlot]===True, Print[ListLogLinearPlot[{c11, c22, c12, c21}, Joined -> True ,PlotLabel->filename,PlotRange -> All, Frame -> True, Axes -> False,  FrameLabel -> {"\[Tau]/sec", "G(\[Tau])"},LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 12, FontWeight -> Bold}]]
]; 
    c11[[All,1]] *= 1000.; c12[[All,1]] *= 1000.; c22[[All,1]] *= 1000.; c21[[All,1]] *= 1000.; 
    {Export[StringJoin[filename, "_c11.dat"], Prepend[c11, {"Corr.Time[ms]", "Correlation(1->2)"}], "Table"], 
     Export[StringJoin[filename, "_c12.dat"], Prepend[Transpose[{c12[[All,1]], c12[[All,2]], c12[[All,2]], c12[[All,2]], 
         c21[[All,2]], c21[[All,2]]}], {"Corr.Time[ms]", "Correlation(1->2)", "Correlation(1->2)", "Correlation(1->2)", 
        "Correlation(2->1)", "Correlation(2->1)"}], "Table"], Export[StringJoin[filename, "_c22.dat"], 
      Prepend[c22, {"Corr.Time[ms]", "Correlation(1->2)"}], "Table"]}]

F2focusFCSExport[filename_String, logtaumin_, logtaumax_, dlogtau_, route1:FRouteList, route2:FRouteList, 
   {(ch11_)?FValidChannelQ, (ch12_)?FValidChannelQ}, {(ch21_)?FValidChannelQ, (ch22_)?FValidChannelQ},opts:OptionsPattern[]] := 
  F2focusFCSExport[filename, logtaumin, logtaumax, dlogtau, route1, route2, {ch11, ch12}, {ch21, ch22}, -1., -1.,opts]


F2fFCSFromTTTR[ logtaumin_, logtaumax_, dlogtau_, route1:FRouteList, route2:FRouteList,{(ch11_)?FValidChannelQ, (ch12_)?FValidChannelQ}, {(ch21_)?FValidChannelQ, (ch22_)?FValidChannelQ},(tstart_)?NumberQ, (tstop_)?NumberQ,opts:OptionsPattern[]] :=
Module[{fcspl, correldat, logcorreldat, c11, c12, c21, c22},
 logcorreldat := ({Log[10, #1[[1]]], #1[[2]]} & ) /@ correldat; fcspl := ListPlot[logcorreldat, Joined -> True, PlotRange -> All,  Frame -> True, Axes -> False, FrameLabel -> {"log(\[Tau]/sec)", "G(\[Tau])"},LabelStyle -> {FontFamily -> "Helvetica", FontSize -> 12, FontWeight -> Bold}]; 
    {c11, c22, c12, c21} = FFCS[logtaumin, logtaumax, dlogtau, {{{route1, {ch11, ch12}}, {route2, {ch11, ch12}}}, 
       {{route1, {ch21, ch22}}, {route2, {ch21, ch22}}}, {{route1, {ch11, ch12}}, {route2, {ch21, ch22}}}, 
       {{route2, {ch21, ch22}}, {route1, {ch11, ch12}}}}, tstart, tstop];  
    c11[[All,1]] *= 1000.; c12[[All,1]] *= 1000.; c22[[All,1]] *= 1000.; c21[[All,1]] *= 1000.; 
    {c11,c22,c12,c21}]

F2fFCSFromTTTR[ logtaumin_, logtaumax_, dlogtau_, route1:FRouteList, route2:FRouteList, 
   {(ch11_)?FValidChannelQ, (ch12_)?FValidChannelQ}, {(ch21_)?FValidChannelQ, (ch22_)?FValidChannelQ},opts:OptionsPattern[]] := 
  F2fFCSFromTTTR[ logtaumin, logtaumax, dlogtau, route1, route2, {ch11, ch12}, {ch21, ch22}, -1., -1.,opts]


F2focusFCSInit[{LambdaEx_?FRealNumberQ,LambdaEm_?FRealNumberQ,FociDistance_?FRealNumberQ,PinholeDiameter_?FRealNumberQ,magnification_?FRealNumberQ}]:= FP2fFCSInit[N@LambdaEx,N@LambdaEm,N@FociDistance,N@PinholeDiameter,N@magnification];
F2focusFCSSetData[{times:{_?FRealNumberQ..},g11:{_?FRealNumberQ..},g22:{_?FRealNumberQ..},g12:{_?FRealNumberQ..},g21:{_?FRealNumberQ..}}]:= FP2fFCSSetData[N@times,N@g11,N@g22,N@g12,N@g21]

F2focusFCSChiSqr[diffs:{_?FRealNumberQ..},kTs:{_?FRealNumberQ..},w0_?FRealNumberQ,R0_?FRealNumberQ,{vx_?FRealNumberQ,vy_?FRealNumberQ,vz_?FRealNumberQ}]:= FP2fFCSChiSqr[N@Abs@diffs,Abs@N@kTs,Abs@N@w0,Abs@N@R0,N@vx,N@vy,N@vz];
F2focusFCSModel[diffs:{_?FRealNumberQ..},kTs:{___?FRealNumberQ},w0_?FRealNumberQ,R0_?FRealNumberQ,{vx_?FRealNumberQ,vy_?FRealNumberQ,vz_?FRealNumberQ}]:= FP2fFCSModel[N@Abs@diffs,N@Abs@kTs,Abs@N@w0,Abs@N@R0,N@vx,N@vy,N@vz];



F2fFCSSettings[{\[Lambda]ex_?NumberQ,\[Lambda]em_?NumberQ,focidistance_?NumberQ,pinhole_?NumberQ,magnification_?NumberQ}]:=Module[{set},
set={F2fFCSLambdaex->\[Lambda]ex,F2fFCSLambdaem->\[Lambda]em,F2fFCSfocidistance->focidistance,F2fFCSpinhole->pinhole,F2fFCSmagnification->magnification};
SetOptions[F2fFCSGetModel,set];
SetOptions[F2fFCSFit,set];
SetOptions[F2fFCSGetLinearCoefficients,set]
]


Clear[F2fFCSGetModel]
Options[F2fFCSGetModel]={FOutput->FGraph,F2fFCSLambdaex->.485,F2fFCSLambdaem->.515,F2fFCSfocidistance->.440,F2fFCSpinhole->150.,F2fFCSmagnification->60}~Join~ Options[ListPlot];

(*Version where amplitudes are obtained internally.*)
F2fFCSGetModel[data:{Repeated[{_?NumberQ..},5]},diffs:{_?NumberQ..},velocities:{_?NumberQ,_?NumberQ,_?NumberQ},kTs:{___?NumberQ},w0_?NumberQ,R0_?NumberQ,nrefractive_?NumberQ,opts:OptionsPattern[]]:=Module[{model,output,pl1,pl2},F2focusFCSInit[{OptionValue[F2fFCSLambdaex]/nrefractive,OptionValue[F2fFCSLambdaem]/nrefractive,OptionValue@F2fFCSfocidistance,OptionValue@F2fFCSpinhole,OptionValue@F2fFCSmagnification}];
F2focusFCSSetData[data];
model=F2focusFCSModel[diffs,kTs,w0,R0,velocities];
output=Map[{Log[10,data[[1]]],#}\[Transpose]&,model];
If[OptionValue[FOutput]===FGraph,
pl1=ListPlot[output,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/ms)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},PlotStyle->AbsoluteThickness[2]];pl2=ListPlot[Map[{Log[10,data[[1]]],#}\[Transpose]&,data[[2;;]]],FilterRules[{opts}, Options[ListPlot]],PlotRange->All];output=Show[pl1,pl2];
];
output
]



(*F2fFCSGetModel[data:{Repeated[{{_?NumberQ,_?NumberQ}..},4]},diffs:{_?NumberQ..},velocities:{_?NumberQ,_?NumberQ,_?NumberQ},kTs:{___?NumberQ},w0_,R0_,nrefractive_?NumberQ,opts:OptionsPattern[]]:=Module[{dat5},
dat5=Join[{data[[1,All,1]]},data[[All,All,2]]];
F2fFCSGetModel[dat5,diffs,velocities,kTs,w0,R0,nrefractive,opts]
]*)

(*Version where amplitudes are given as functions arguments.*)
F2fFCSGetModel[lagtimes:{_?NumberQ..},diffs:{{_?NumberQ,{_?NumberQ,_?NumberQ}}..},velocities:{vx_?FRealNumberQ,vy_?FRealNumberQ,vz_?FRealNumberQ},kTs:{{_?NumberQ,{_?NumberQ,_?NumberQ,_?NumberQ,_?NumberQ}}...},offsets:{_?NumberQ,_?NumberQ,_?NumberQ,_?NumberQ},w0_?NumberQ,R0_?NumberQ,nrefractive_?NumberQ,opts:OptionsPattern[]]:=
Module[{vecdat,coeff,output},F2focusFCSInit[{OptionValue[F2fFCSLambdaex]/nrefractive,OptionValue[F2fFCSLambdaem]/nrefractive,OptionValue@F2fFCSfocidistance,OptionValue@F2fFCSpinhole,OptionValue@F2fFCSmagnification}];
vecdat=FP2fFCSModelVectors[lagtimes,diffs[[All,1]],kTs[[All,1]],w0,R0,N@vx,N@vy,N@vz];
coeff=Map[{#[[1]],#[[2]],Sqrt[#[[1]]*#[[2]]],Sqrt[#[[1]]*#[[2]]]}&,diffs[[All,2]]];
coeff=Join[coeff,kTs[[All,2]],{offsets}]\[Transpose];
output=MapThread[{Log[10,lagtimes],Total[#1\[Transpose]#2]}\[Transpose]&,{vecdat,coeff}];
If[OptionValue[FOutput]===FGraph,
output=ListPlot[output,FilterRules[{opts}, Options[ListPlot]],Joined->True,PlotRange->All,Frame->True,Axes->False,FrameLabel->{"log(\[Tau]/ms)", "G(\[Tau])"},LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold},PlotStyle->AbsoluteThickness[2]];
];
output
]

F2fFCSGetModel[data:{Repeated[{_?NumberQ..},5]},diffs:{{_?NumberQ,{_?NumberQ,_?NumberQ}}..},velocities:{_?NumberQ,_?NumberQ,_?NumberQ},kTs:{{_?NumberQ,{_?NumberQ,_?NumberQ,_?NumberQ,_?NumberQ}}...},offsets:{_?NumberQ,_?NumberQ,_?NumberQ,_?NumberQ},w0_?NumberQ,R0_?NumberQ,nrefractive_?NumberQ,opts:OptionsPattern[]]:=F2fFCSGetModel[data[[1]],diffs,velocities,kTs,offsets,w0,R0,nrefractive,opts]


F2fFCSGetModel[data:{Repeated[{{_?NumberQ,_?NumberQ}..},4]},var__]:=
Module[{dat5},
dat5=Join[{data[[1,All,1]]},data[[All,All,2]]];F2fFCSGetModel[dat5,var]
]


Options[F2fFCSGetLinearCoefficients]={F2fFCSLambdaex->.485,F2fFCSLambdaem->.515,F2fFCSfocidistance->.440,F2fFCSpinhole->150.,F2fFCSmagnification->60};
F2fFCSGetLinearCoefficients[data:{Repeated[{_?NumberQ..},5]},diffs:{_?NumberQ..},{vx_?FRealNumberQ,vy_?FRealNumberQ,vz_?FRealNumberQ},kTs:{___?NumberQ},w0_,R0_,nrefractive_?NumberQ,opts:OptionsPattern[]]:=Module[{},
F2focusFCSInit[{OptionValue[F2fFCSLambdaex]/nrefractive,OptionValue[F2fFCSLambdaem]/nrefractive,OptionValue@F2fFCSfocidistance,OptionValue@F2fFCSpinhole,OptionValue@F2fFCSmagnification}];
F2focusFCSSetData[data];
FP2fFCSLinearCoefficients[N@Abs@diffs,N@Abs@kTs,N@Abs@w0,N@Abs@R0,N@vx,N@vy,N@vz]
]

F2fFCSGetLinearCoefficients[data:{Repeated[{{_?NumberQ,_?NumberQ}..},4]},diffs:{_?NumberQ..},velocities:{_?NumberQ,_?NumberQ,_?NumberQ},kTs:{___?NumberQ},w0_,R0_,nrefractive_?NumberQ,opts:OptionsPattern[]]:=Module[{dat5},
dat5=Join[{data[[1,All,1]]},data[[All,All,2]]];
F2fFCSGetLinearCoefficients[dat5,diffs,velocities,kTs,w0,R0,nrefractive,opts]
]


Options[F2fFCSFit]={FConstraints->None,PrecisionGoal->5,AccuracyGoal->Automatic}~Join~Options[F2fFCSGetModel]~Join~ Options[ListPlot]~Join~Options[FindMinimum];
F2fFCSFit[data:{Repeated[{_?NumberQ..},5]},diffs_List,velocities:{_,_,_},kTs_List,w0_,R0_,nrefractive_,guess:{{_,_?NumberQ}..},opts:OptionsPattern[]]:=Module[{gdata,f,R,objectiveFunction,params,fitresult,output},
F2focusFCSInit[{OptionValue[F2fFCSLambdaex]/nrefractive,OptionValue[F2fFCSLambdaem]/nrefractive,OptionValue@F2fFCSfocidistance,OptionValue@F2fFCSpinhole,OptionValue@F2fFCSmagnification}];
F2focusFCSSetData[data];
gdata=Flatten[data[[2;;]]];
params=guess[[All,1]];
f[var:{___?NumberQ}]:=Flatten@F2focusFCSModel[Sequence@@({Abs@diffs,Abs@kTs,Abs@w0,Abs@R0,velocities}/.Map[Rule@@#&,{params,var}\[Transpose]])];
R[{vars___?NumericQ}]:=f[{vars}]-gdata;
objectiveFunction[{params___?NumericQ}]:=Norm[f[{params}]-gdata,2];
If[OptionValue[FConstraints]=!=None,fitresult=FindMinimum[{objectiveFunction[params],OptionValue[FConstraints]},guess,Evaluate[Sequence@@FilterRules[{opts}, Options[FindMinimum]]],Evaluate[Sequence@@FilterRules[Options[F2fFCSFit], Options[FindMinimum]]]],fitresult=FindMinimum[objectiveFunction[params],guess,Evaluate[Sequence@@FilterRules[{opts}, Options[FindMinimum]]],Method->{"LevenbergMarquardt","Residual"->R[params]},Evaluate[Sequence@@FilterRules[Options[F2fFCSFit], Options[FindMinimum]]]];fitresult[[1]]*=2.;
];
output=F2fFCSGetModel[data,Abs@diffs,velocities,Abs@kTs,Abs@w0,Abs@R0,nrefractive,FilterRules[{opts}, Options[F2fFCSGetModel]]]/.fitresult[[2]];
{ fitresult[[1]],fitresult[[2]],output}
]

F2fFCSFit[data:{Repeated[{{_?NumberQ,_?NumberQ}..},4]},diffs_List,velocities:{_,_,_},kTs_List,w0_,R0_,nrefractive_,guess:{{_,_?NumberQ}..},opts:OptionsPattern[]]:=Module[{dat5},
dat5=Join[{data[[1,All,1]]},data[[All,All,2]]];
F2fFCSFit[dat5,diffs,velocities,kTs,w0,R0,nrefractive,guess,opts]
]



Options[F2fFCSGlobalFit]={FConstraints->None,PrecisionGoal->5,AccuracyGoal->Automatic}~Join~Options[F2fFCSGetModel]~Join~Options[FindMinimum]~Join~ Options[ListPlot];

F2fFCSGlobalFit[dataset:{{{Repeated[{_?NumericQ..},5]},{_List,{_,_,_},_List,_,_,_}}..},guess:{{_,_?NumericQ}..},opts:OptionsPattern[]]:=
Module[{gdata,f,R,objectiveFunction,params,fitresult,output},
gdata=Flatten[dataset[[All,1,2;;]]];
params=guess[[All,1]];
f[var:{___?NumericQ}]:=
Module[{rules=Map[Rule@@#&,{params,var}\[Transpose]]},
Flatten@Map[(
F2focusFCSInit[{OptionValue[F2fFCSLambdaex]/#[[2,-1]],OptionValue[F2fFCSLambdaem]/#[[2,-1]],OptionValue@F2fFCSfocidistance,OptionValue@F2fFCSpinhole,OptionValue@F2fFCSmagnification}/.rules];
F2focusFCSSetData[#[[1]]];
Flatten@F2focusFCSModel[Sequence@@({Abs@#[[2,1]],Abs@#[[2,3]],Abs@#[[2,4]],Abs@#[[2,5]],#[[2,2]]}/.rules)])&,
dataset]
];
R[{vars___?NumericQ}]:=f[{vars}]-gdata;
objectiveFunction[{params___?NumericQ}]:=Norm[f[{params}]-gdata,2];
If[OptionValue[FConstraints]=!=None,fitresult=FindMinimum[{objectiveFunction[params],OptionValue[FConstraints]},guess,Evaluate[Sequence@@FilterRules[{opts}, Options[FindMinimum]]],Evaluate[Sequence@@FilterRules[Options[F2fFCSGlobalFit], Options[FindMinimum]]]],fitresult=FindMinimum[objectiveFunction[params],guess,Evaluate[Sequence@@FilterRules[{opts}, Options[FindMinimum]]],Method->{"LevenbergMarquardt","Residual"->R[params]},Evaluate[Sequence@@FilterRules[Options[F2fFCSGlobalFit], Options[FindMinimum]]]];fitresult[[1]]*=2.;];
output=Map[F2fFCSGetModel[#[[1]],Abs@#[[2,1]],#[[2,2]],Abs@#[[2,3]],Abs@#[[2,4]],Abs@#[[2,5]],#[[2,6]],FilterRules[{opts}, Options[F2fFCSGetModel]]]&,dataset]/.fitresult[[2]];
{ fitresult[[1]],fitresult[[2]],output}
]

F2fFCSGlobalFit[dataset:{{{Repeated[{{_?NumericQ,_?NumericQ}..},4]},{_List,{_,_,_},_List,_,_,_}}..},guess:{{_,_?NumericQ}..},opts:OptionsPattern[]]:=Module[{dat5},
dat5=Map[{Join[{#[[1,1,All,1]]},#[[1,All,All,2]]],#[[2]]}&,dataset];
F2fFCSGlobalFit[dat5,guess,opts]
]


FCalculateBurstListFromScanImagePixels[frame_Integer]:=FPCalculateBurstListFromScanImagePixels[frame-1];
FCalculateBurstListFromScanImagePixels[]:=FCalculateBurstListFromScanImagePixels[1]



FGetFromPiezoScan::noscan="No image scan is loaded"; 
FGetFromPiezoScan[expr_,frame_Integer]:=Module[{dat},
If[Length[StringCases[FShowHeader[],"ImgHdr_Dimensions"]]==1,
FCalculateBurstListFromScanImagePixels[frame];
dat=Partition[FGetFromBurstList[expr],FGetFromHeader["ImgHdr_PixX"]];
If[FGetFromHeader["ImgHdr_BiDirect"]!=0,
Do[dat[[i]]=Reverse[dat[[i]]],{i,2,Length[dat],2}]];
dat,Message[FGetFromPiezoScan::noscan]
]
]
FGetFromPiezoScan[expr_]:=FGetFromPiezoScan[expr,1]


ReleaseHoldAt[expr_,partspec_]:=ReplacePart[expr,partspec->Extract[expr,partspec]]


lifetimecolor[{intensity_,tau_}]:={(1-tau) 0.7,1,intensity };
ScaleTo[datas_,{i1_,i2_},{tau1_,tau2_}]:=Module[{dat=datas},
dat[[All,All,1]]=Rescale[dat[[All,All,1]],{i1,i2}];
dat[[All,All,2]]=Rescale[dat[[All,All,2]],{tau1,tau2}];
Clip[dat,{0,1}]
];

Clear[FScanImage];
Options[FScanImage]={FScanImageParamName->"param"}~Join~Options[Graphics];
FScanImage[data_?(ArrayQ[#,2]&),{intensity1_?NumberQ,intensity2_?NumberQ},{x0_?NumberQ,y0_?NumberQ,resolx_?NumberQ,resoly_?NumberQ},opts:OptionsPattern[]]:=Module[{ndat,img,nx,ny,xmax,ymax,GetPixel,dfunc,flim},
ndat=Clip[Rescale[data,{intensity1,intensity2}],{0,1}];
img=Image[ndat];
{ny,nx}=Dimensions[data][[1;;2]];
xmax=x0+nx resolx ;
ymax=y0+ny resoly ;
GetPixel[{x_,y_}]:=Ceiling[{(x-x0)/resolx,ny-(y-y0)/resoly}];
dfunc[pt_]:=Module[{pix=GetPixel[pt],int},int=If[0<pix[[1]]<=nx && 0<pix[[2]]<=ny ,data[[Sequence@@Reverse@GetPixel[pt]]],0];Column[{"{x,y}="<>ToString[Round[100.pt]/100.],"intensity="<>ToString[int]}]
];
flim=Graphics[Inset[Show[img,AspectRatio->Full],{x0,y0},{0,0},{xmax-x0,ymax-y0}],FilterRules[{opts}, Options[Graphics]],PlotRange->{{x0,xmax},{y0,ymax}},Frame->True,FrameLabel->{"\[Mu]m","\[Mu]m"},CoordinatesToolOptions->{"DisplayFunction"->dfunc},ImageSize->300,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold}];
flim
]

FScanImage[dat_?(ArrayQ[#,2]&),{intensity1_,intensity2_},opts:OptionsPattern[]]:=Module[{ScanDirection,origin},
ScanDirection=FGetFromHeader["ImgHdr_ScanDirection"];
origin=Which[
ScanDirection==0, {FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Y0"]},
ScanDirection==1, {FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Z0"]},
ScanDirection==2, {FGetFromHeader["ImgHdr_Y0"],FGetFromHeader["ImgHdr_Z0"]},
True,{FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Y0"]}
];
FScanImage[dat,{intensity1,intensity2},origin~Join~{FGetFromHeader["ImgHdr_PixResol"],FGetFromHeader["ImgHdr_PixResol"]},opts]
]

FScanImage[data_?(ArrayQ[#,3]&),{intensity1_?NumberQ,intensity2_?NumberQ},{param1_?NumberQ,param2_?NumberQ},{x0_?NumberQ,y0_?NumberQ,resolx_?NumberQ,resoly_?NumberQ},opts:OptionsPattern[]]:=Module[{ndat,img,nx,ny,xmax,ymax,GetPixel,dfunc,flim},
ndat=ScaleTo[data,{intensity1,intensity2},{param1,param2}];
img=Image[Map[lifetimecolor,ndat,{2}],ColorSpace->"HSB"];
{ny,nx}=Dimensions[data][[1;;2]];
xmax=x0+nx resolx ;
ymax=y0+ny resoly ;
GetPixel[{x_,y_}]:=Ceiling[{(x-x0)/resolx,ny-(y-y0)/resoly}];dfunc[pt_]:=Module[{pix=GetPixel[pt],itau},itau=If[0<pix[[1]]<=nx && 0<pix[[2]]<=ny ,data[[Sequence@@Reverse@GetPixel[pt]]],{0,0}];Column[{"{x,y}="<>ToString[Round[100.pt]/100.],"intensity="<>ToString[itau[[1]]],(OptionValue[FScanImageParamName])<>ToString[itau[[2]]]}]
];
flim=Graphics[Inset[Show[img,AspectRatio->Full],{x0,y0},{0,0},{xmax-x0,ymax-y0}],FilterRules[{opts}, Options[Graphics]],PlotRange->{{x0,xmax},{y0,ymax}},Frame->True,FrameLabel->{"\[Mu]m","\[Mu]m"},CoordinatesToolOptions->{"DisplayFunction"->dfunc},ImageSize->300,LabelStyle->{FontFamily-> "Helvetica",FontSize-> 12,FontWeight-> Bold}];
flim
]

FScanImage[dat_?(ArrayQ[#,3]&),{intensity1_,intensity2_},{param1_,param2_},opts:OptionsPattern[]]:=Module[{ScanDirection,origin},
ScanDirection=FGetFromHeader["ImgHdr_ScanDirection"];
origin=Which[
ScanDirection==0, {FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Y0"]},
ScanDirection==1, {FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Z0"]},
ScanDirection==2, {FGetFromHeader["ImgHdr_Y0"],FGetFromHeader["ImgHdr_Z0"]},
True,{FGetFromHeader["ImgHdr_X0"],FGetFromHeader["ImgHdr_Y0"]}
];
FScanImage[dat,{intensity1,intensity2},{param1,param2},origin~Join~{FGetFromHeader["ImgHdr_PixResol"],FGetFromHeader["ImgHdr_PixResol"]},opts]
]

Clear[FFastFLIM]
Options[FFastFLIM]={}~Join~Options[FScanImage];
FFastFLIM[routes:FRouteList,t0_,{i1_,i2_},{tau1_,tau2_},frame_Integer,opts:OptionsPattern[]]:=Module[
{r,p,dat,ndat,img,nx,ny,xmin,xmax,ymin,ymax,\[CapitalDelta]pix,GetPixel,dfunc,flim},
r=Select[MapIndexed[#1 #2[[1]]&,routes],#>0&];p=Map[{"n"<>ToString[#],"tau"<>ToString[#]}&,r];p={Total[p[[All,1]]],Total@Map[Times@@#&,p]};dat=FGetFromPiezoScan[ReleaseHoldAt[Hold[Transpose[p]],{1,1}],frame];dat=Map[{#[[1]],#[[2]]/Max[#[[1]],1]-t0}&,dat,{2}];flim=FScanImage[dat,{i1,i2},{tau1,tau2},FilterRules[{opts}, Options[FScanImage]],FScanImageParamName->"tau="];{dat,flim}
]
FFastFLIM[routes:FRouteList,t0_,{i1_,i2_},{tau1_,tau2_},opts:OptionsPattern[]]:=FFastFLIM[routes,t0,{i1,i2},{tau1,tau2},1,opts]

FScanImageColorLegend[{i1_,i2_},{tau1_,tau2_},opts:OptionsPattern[]]:=Module[{dat,di,dt},
dat=Reverse@Table[{i,t},{i,i1,i2,di=(i2-i1)/10.},{t,tau1,tau2,dt=(tau2-tau1)/50.}];
FScanImage[dat,{i1,i2},{tau1,tau2},{tau1,i1,dt,di},FilterRules[{opts}, Options[FScanImage]],AspectRatio->0.3,FrameLabel->{"parameter","intensity"}]
]

FGetScanImageCoordinatesFromTime[time_?NumberQ]:=FPGetScanImageCoordinatesFromTime[N@time]
SetAttributes[FGetScanImageCoordinatesFromTime,Listable];


FHmmTrajectory={{{_?NumberQ ..},{_?NumberQ ..},{_?NumberQ ..},{_?NumberQ ..}},{{_?NumberQ ,_?NumberQ }..}};(*acceptor and donor counts*)
FHmmClearTrajectoryList[]:=FPHmmClearTrajectoryList[]

FHmmAppendToTrajectoryList[tr:FHmmTrajectory]:=FPHmmAppendTrajectory[Round@Flatten@tr[[2]],N@tr[[1,1]],N@tr[[1,2]],FHmmBinning*N@tr[[1,3]],FHmmBinning*Round@N@tr[[1,4]]]


FHmmBinning=1.;
FHmmInitTrajectoryList[trajectorylist:{FHmmTrajectory..},binning_?NumberQ]:=
Module[{},
FHmmBinning=binning;
FHmmClearTrajectoryList[];
Map[FPHmmAppendTrajectory2,Round@N@trajectorylist[[All,2]]];
FPHmmSetPhotonRates[N@FHmmBinning*trajectorylist[[All,1,3;;4]]];
FPHmmSetPinPfin[N@Flatten@trajectorylist[[All,1,1]],N@Flatten@trajectorylist[[All,1,2]],Length@trajectorylist[[1,1,1]]];

]
FHmmSetPhotonRates[rates:{{_List,_List}..}]:=FPHmmSetPhotonRates[N@FHmmBinning*rates]

FHmmLikelihood[Km_?SquareMatrixQ]:=FPHmmGetLikelihood[FHmmBinning*N@Km]
FHmmLikelihoodPeqFromK[Km_?FNumericSquareMatrixQ]:=FPHmmGetLikelihoodPeqFromK[FHmmBinning*N@Km]
FHmmLikelihoodPeqFromK[na:{_?NumberQ..},nd:{_?NumberQ..},Km_?FNumericSquareMatrixQ]:=FPHmmGetLikelihoodPeqFromKrates[FHmmBinning*N@Km,FHmmBinning*N@{na,nd}]
FHmmViterbiPeqFromK[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmmViterbiPeqFromK[FHmmBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]
FHmmViterbi[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmmViterbi[FHmmBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]








FMLHTrajectory={{{_?NumberQ ..},{_?NumberQ ..}},{{_?NumberQ,_Integer}..}}|{{{_?NumberQ ..},{_?NumberQ ..},_?FNumericMatrixQ},{{_?NumberQ,_Integer}..}}|{{{_?NumberQ..},{_?NumberQ..},{_?NumberQ..},{_?NumberQ..}},{{_?NumberQ,_Integer}..}};
FMLHClearBurstList[]:=FPClearMLHBurstList[]
FMLHBurstListLength[]:=FPMLHBurstListLength[]
FMLHAppendToBurstList[burst:{{_?NumberQ,_Integer}..}]:=FPMLHAppendBurst[burst[[All,1]],burst[[All,2]],{1.,1.},{1.,1.},{{1.,1.},{1.,1.}}]
FMLHAppendToBurstList[{{pinital:{_?NumberQ ..},pfinal:{_?NumberQ ..}},burst:{{_?NumberQ,_Integer}..}}]:=FPMLHAppendBurst[N@burst[[All,1]],burst[[All,2]],N@pinital,N@pfinal,{{1.,1.},{1.,1.}}]
FMLHAppendToBurstList[{{pinital:{_?NumberQ ..},pfinal:{_?NumberQ ..},photonrates_?FNumericMatrixQ },burst:{{_?NumberQ,_Integer}..}}]:=FPMLHAppendBurst[N@burst[[All,1]],burst[[All,2]],N@pinital,N@pfinal,N@photonrates]

FMLHAppendToBurstList[{{pinital:{_?NumberQ..},pfinal:{_?NumberQ..},na:{_?NumberQ..},nd:{_?NumberQ..}},burst:{{_?NumberQ,_Integer}..}}]:=FPMLHAppendBurst[N@burst[[All,1]],burst[[All,2]],N@pinital,N@pfinal,N@{na,nd}]

FMLHSetPhotonRates[photonrates:{_?FNumericMatrixQ ..}]:=FPMLHSetPhotonRates[N@photonrates]

Options[FMLHInitBurstList]={FBurstData->All,FMLHFirstTauZero->True};
FMLHInitBurstList[opts:OptionsPattern[]]:=Module[{selected=0,tau0=1},
Which[
OptionValue[FBurstData]===All,selected=0
,OptionValue[FBurstData]===FSelectedBursts,selected=1
,True,{}
];
If[OptionValue[FMLHFirstTauZero],tau0=1,tau0=0];
FPInitBurstListForMLH[selected,tau0,{1,2,1,2,0,0}]
]

FMLHInitBurstList[trajectorylist:{FMLHTrajectory..}]:=Module[{},
FMLHClearBurstList[];
FMLHAppendToBurstList/@trajectorylist;
FMLHBurstListLength[]
]




FMLHGetLikelihoodVpeqFromK[Km_?FNumericSquareMatrixQ,VList:{_?FNumericSquareMatrixQ ..}]:=FPMLHGetLikelihoodVpeqFromK[Km,VList]


FMLHGetLikelihoodpeqFromKconstNtot[photonrates_?FNumericMatrixQ,Km_?FNumericSquareMatrixQ]:=FPMLHGetLikelihoodpeqFromKconstNtot[N@photonrates,N@Km]
FMLHGetLikelihood[Km_?FNumericSquareMatrixQ]:=FPMLHGetLikelihood[N@Km]
FMLHGetLikelihood[photonrates_?FNumericMatrixQ,Km_?FNumericSquareMatrixQ]:=FPMLHGetLikelihood[N@photonrates,N@Km]
FMLHGetLikelihoodPeqFromK[Km_?FNumericSquareMatrixQ]:=FPMLHGetLikelihoodPeqFromK[N@Km]
FMLHGetLikelihoodPeqFromK[photonrates_?FNumericMatrixQ,Km_?FNumericSquareMatrixQ]:=FPMLHGetLikelihoodPeqFromK[N@photonrates,N@Km]


FMLHTransitionStatesGetLikelihoods[Km:{_?SquareMatrixQ..},tslevels_List]:=Module[{},
If[Length[Km[[1]]]==Length[tslevels]+2
,Partition[FPMLHTransitionStatesGetLikelihoods[N@Flatten@Km,Length[Km[[1]]],Length[Km],tslevels],Length[Km]]
,4711]
]

FMLHTransitionStatesGetLikelihoods[Km:{_?SquareMatrixQ..}]:=Module[{},
Partition[FPMLHTransitionStatesGetLikelihoods[N@Flatten@Km,Length[Km[[1]]],Length[Km]],Length[Km]]
]


FMLHViterbi[Km_?FNumericSquareMatrixQ]:=FPMLHViterbi[N@Km]

FMLHViterbi[photonrates_?FNumericMatrixQ, Km_?FNumericSquareMatrixQ,p0:{_?NumberQ..}]:=
Module[{cpts},
cpts=If[Dimensions[photonrates][[2]]==Length[Km]
,FPMLHViterbi[N@photonrates,N@Km,N@p0]
,4711];
cpts
]

FMLHViterbiPeqFromK[Km_?FNumericSquareMatrixQ]:=Module[{},
FPMLHViterbiPeqFromK[N@Km]
]


(*
FMLHRecolor[{efret:{_?NumberQ..},\[Lambda]:{_?NumberQ..},U:{{_?NumberQ..}..},Uinv:{{_?NumberQ..}..},p0:{_?NumberQ..},kother_?NumberQ}]:=
Module[{na,nd},
na=N@efret;
nd=N[1-efret];
If[Length[efret]==Length[\[Lambda]]==Length[U]==Length[Uinv]==Length[p0] &&Equal@@Dimensions[U] &&Equal@@Dimensions[Uinv]
,FPMLHRecolor2[na,nd,\[Lambda],Flatten[U],Flatten[Uinv],p0,N@kother]
,4711]
]

FMLHFret[burst_]:=Module[{nd,na},
na=Count[burst,{_,0}];
nd=Count[burst,{_,1}];
na/(na+nd)
]
*)
FMLHGetBursts[istart_Integer,istop_Integer]:=FPGetMLHBurstList[istart,istop]


FDwellList[][transition_Rule]:=FDwellList[]
FDwellList[dwells:_FDwell ..][transition_Rule]:=FDwellList@@Cases[{dwells},FDwell[_,transition,___]]
FDwellList[dwells:_FDwellList ..][transition_Rule]:=FDwellList@@Map[#[transition]&,{dwells}];
FDwellList[dwells___]["t"]:={dwells}/.FDwell[t_,___]->t/.FDwellList->List
FDwellList[dwells___]["transition"]:={dwells}/.FDwell[_,transition_,___]->transition/.FDwellList->List
FDwellList[dwells___]["state"]:={dwells}/.FDwell[_,s_->_,___]->s/.FDwellList->List
FDwellList[dwells___]["dt"]:={dwells}/.FDwell[_,_,dt_,___]->dt/.FDwellList->List
FDwellList[dwells___]["Na"]:={dwells}/.FDwell[_,_,_,{na_,___},___]->na/.FDwellList->List
FDwellList[dwells___]["Nd"]:={dwells}/.FDwell[_,_,_,{_,nd_,___},___]->nd/.FDwellList->List
FDwellList[dwells___]["PhotonRates"]:={dwells}/.FDwell[_,_,dt_,n_,___]->n/dt/.FDwellList->List
FDwellList[dwells___][expr_?(!StringQ[#]&)]:=expr/.s_String:>FDwellList[dwells][s]


FDwellList[dwells___]["stategraph",t0_,scale_,offset_]:={dwells}/.FDwell[t_,s1_->s2_,dt_,___]:>Sequence[{t0+t,scale s1+offset},{t0+t+dt,scale s1+offset}]
FDwellList[dwells___]["mcs",t0_,ratefunc_]:={dwells}/.FDwell[t_,s1_->s2_,dt_,___]:>Sequence[{t0+t,ratefunc[s1]},{t0+t+dt,ratefunc[s1]}]





(* ::Input::Initialization:: *)
CombineTransitions[dwells:FDwellList[_FDwell..]]:=Module[{},
FDwell[dwells[[1,1]],dwells[[1,2,1]]->dwells[[-1,2,2]],Total[List@@dwells[[All,3]]],Total[List@@dwells[[All,4]]]]
]


(* ::Input::Initialization:: *)
FJoinSelftransitions[dwells:FDwellList[_FDwell..]]:=CombineTransitions/@Split[dwells,#2[[2,1]]==#1[[2,1]]&]
FJoinSelftransitions[dwells:FDwellList[_FDwellList..]]:=FJoinSelftransitions/@dwells


(* ::Input::Initialization:: *)
FRenameStates[dwells:FDwellList[_FDwell..],rename:{_Rule..}]:=Module[{newdwells,pos,new,deletepos},
newdwells=dwells;
newdwells[[All,2]]=List@@newdwells[[All,2]]/.rename;
FJoinSelftransitions@newdwells
]
FRenameStates[FDwellList[],_]:=FDwellList[]
FRenameStates[dwells:FDwellList[_FDwellList..],rename:{_Rule..}]:=Map[FRenameStates[#,rename]&,dwells]





FSplitTrajectory[dwells:FDwellList[_FDwell ..],T_]:=Module[{t0,tf,nbins,split,dw,s,sf,dwi},
t0=dwells[[1,1]];
tf=dwells[[-1,1]]+dwells[[-1,3]];
nbins=Floor[(tf-t0)/T]+1;

Do[split[i]=FDwellList[],{i,nbins}];
Do[

dw=dwells[[i]];
s=Floor[(dw[[1]]-t0)/T]+1;
sf=Ceiling[(dw[[1]]+dw[[3]]-t0)/T];
While[sf!=s,
dwi=dw;
dwi[[2,2]]=dwi[[2,1]];
dwi[[3]]=t0+s*T-dwi[[1]];
AppendTo[split[s],dwi];
dw[[1]]=t0+s*T;
dw[[3]]-=dwi[[3]];
s=Floor[(dw[[1]]-t0)/T]+1;
sf=Ceiling[(dw[[1]]+dw[[3]]-t0)/T];
];
AppendTo[split[s],dw];

,{i,Length[dwells]}
];
FDwellList@@Table[split[s],{s,nbins}]
]


FHmmBinning=1.;
FHMMmode=None;
FHMMTrajectoryCount=0;
FHMMStateCount=0;
FHMMGlobalRates=False;
FHMMNa={1,1};
FHMMNd={1,1};
FHMMRate={};


FHMMInitWithBinnedData[trlist:{{{_Integer.. }..}..},Tbinning_?NumericQ]:=Module[{},

FHmmBinning=Tbinning;
FHmmClearTrajectoryList[];
(*unitv=ConstantArray[1.,2];*)
(*Map[FPHmmAppendTrajectory[Round@Flatten@#,unitv,unitv,unitv,unitv]&,trlist];*)
Map[FPHmmAppendTrajectory2,trlist];
FHMMmode=FHMMBinned;
FHMMTrajectoryCount=Length[trlist];
FHMMStateCount=0;
]


FHMMInitWithPhotonByPhotonData[trlist:{{{_?NumericQ ,_Integer }..}..}]:=Module[{unitv,tr},
FMLHClearBurstList[];
unitv=ConstantArray[1,2];
Map[FMLHAppendToBurstList[(tr={{unitv,unitv,{unitv,unitv}},#};tr[[2,All,2]]-=1;tr)]&,trlist];
FHMMmode=FHMMPhotonByPhoton;
FHMMTrajectoryCount=Length[trlist];
FHMMStateCount=0;
]


Options[FHMMInitWithPhotonByPhotonDataFromBurstList]={FBurstData->All,FHMMFirstTauZero->True};
FHMMInitWithPhotonByPhotonDataFromBurstList[colormap:{_Integer..},opts:OptionsPattern[]]:=Module[{selected=0,tau0=1,n},
Which[
OptionValue[FBurstData]===All,selected=0,
OptionValue[FBurstData]===FSelectedBursts,selected=1,True,{}
];
If[OptionValue[FHMMFirstTauZero],tau0=1,tau0=0];n=FPInitBurstListForMLH[selected,tau0,colormap];
FHMMmode=FHMMPhotonByPhoton;
FHMMTrajectoryCount=n;
FHMMStateCount=0;
n
]





(*FHMMSetPhotonRates[rates:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[rates[[1,1]]];
If[AnyTrue[rates,Length[#]\[NotEqual]nstates&,2],(Message[FHMMSetPhotonRates::dimerr];Return[$Failed])];
FHMMGlobalRates=False;
Which[
FHMMmode===FHMMBinned,FPHmmSetPhotonRates[N@FHmmBinning*Flatten@rates[[All,1]],N@FHmmBinning*Flatten@rates[[All,2]],Length@rates[[1,1]]],
FHMMmode===FHMMPhotonByPhoton,FMLHSetPhotonRates[rates],
True,(Message[FHMMSetPhotonRates::erroptval];Return[$Failed])
];
FHMMStateCount=nstates;
]*)
FHMMSetPhotonRates[rates:{_?FNumericMatrixQ..}]:=Module[{nstates},
nstates=Length[rates[[1,1]]];
If[AnyTrue[rates,Length[#]!=nstates&,2],(Message[FHMMSetPhotonRates::dimerr];Return[$Failed])];
FHMMGlobalRates=False;
Which[
FHMMmode===FHMMBinned,FPHmmSetPhotonRates[N@FHmmBinning*rates],
FHMMmode===FHMMPhotonByPhoton,FMLHSetPhotonRates[rates],
True,(Message[FHMMSetPhotonRates::erroptval];Return[$Failed])
];
FHMMStateCount=nstates;
]
FHMMSetPhotonRates[rates_?FNumericMatrixQ]:=Module[{},
(*If[Length[nA]!=Length[nD] ,(Message[FHMMSetPhotonRates::dimerr];Return[$Failed])];*)
FHMMSetPhotonRates[ConstantArray[rates,FHMMTrajectoryCount]];
FHMMGlobalRates=True;
FHMMRate=rates
]


FHMMSetPinPfin[pinpfin:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[pinpfin[[1,1]]];
If[AnyTrue[pinpfin,Length[#]!=nstates&,2],Return[$Failed]];
FHMMGlobalRates=False;
Which[
FHMMmode===FHMMBinned
,FPHmmSetPinPfin[N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
FHMMmode===FHMMPhotonByPhoton
,FPMLHSetPinPfin[N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
True,$Failed
]
]

FHMMSetPinPfin[{pin:{_?NumericQ..}, pfin:{_?NumericQ..}}]:=Module[{},
(*If[Length[pin]!=FHMMStateCount || Length[pfin]!=FHMMStateCount,Return[$Failed]];*)
FHMMSetPinPfin[ConstantArray[{pin,pfin},FHMMTrajectoryCount]]

]






Options[FHMMLogLikelihood]={FHMMpinpfin->FHMMPeqOne};
FHMMLogLikelihood[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{lh},
If[Length[Km]!=FHMMStateCount,(Message[FHMMLogLikelihood::dimerr];Return[$Failed])];
Which[FHMMmode===FHMMBinned,
lh=Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,FPHmmGetLikelihoodPeqFromKrates[FHmmBinning*N@Km,FHmmBinning*N@FHMMRate],FPHmmGetLikelihoodPeqFromK[FHmmBinning*N@Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPHmmGetLikelihood[FHmmBinning*N@Km],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,FHMMmode===FHMMPhotonByPhoton,
lh=-
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,FPMLHGetLikelihoodPeqFromK[N@FHMMRate,N@Km],FPMLHGetLikelihoodPeqFromK[N@Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,If[FHMMGlobalRates,FPMLHGetLikelihood[N@FHMMRate,N@Km],FPMLHGetLikelihood[N@Km]],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,True,(Message[FHMMLogLikelihood::noinit];Return[$Failed])
];
lh
]
FHMMLogLikelihood[Km_?FNumericSquareMatrixQ, photonrates:{_?FNumericMatrixQ..}|_?FNumericMatrixQ,opts:OptionsPattern[]]:=Module[{lh},
If[FHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FHMMLogLikelihood[Km,opts]
]


FHMMGetLogLikelihoodList[]:= Module[{},
Which[FHMMmode===FHMMBinned,
FPHmmGetLikelihoodList[]
,FHMMmode===FHMMPhotonByPhoton,
FPMLHGetLikelihoodList[]
,True,(Message[FHMMLogLikelihood::noinit];Return[$Failed])
]
]


FHMMTransitionStatesLogLikelihoods[expr___]:=If[FHMMmode===FHMMPhotonByPhoton,FMLHTransitionStatesGetLikelihoods[expr],$Failed]


BinnedViterbiPeqFromK[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmmViterbiPeqFromK[FHmmBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]
BinnedViterbi[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmmViterbi[FHmmBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]



Options[FHMMViterbi]={FHMMpinpfin->FHMMPeqOne};
FHMMViterbi[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=FHMMStateCount,(Message[FHMMViterbi::dimerr];Return[$Failed])];
Which[
FHMMmode===FHMMBinned
,statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,BinnedViterbiPeqFromK[Km],BinnedViterbiPeqFromK[Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,BinnedViterbi[Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
],
FHMMmode===FHMMPhotonByPhoton,
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,FPMLHViterbiPeqFromK[N@Km],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPMLHViterbi[N@Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
]
,True,(Message[FHMMViterbi::noinit];Return[$Failed])
];
statetrajectory
]
FHMMViterbi[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[FHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FHMMViterbi[Km]
]


Options[FHMMForwardBackward]={FHMMpinpfin->FHMMPeqOne};
FHMMForwardBackward[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=FHMMStateCount,(Message[FHMMViterbi::dimerr];Return[$Failed])];
Which[
FHMMmode===FHMMBinned
,statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,$False,FPHmmForwardBackwardPeqFromK[FHmmBinning*N@Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPHmmForwardBackward[FHmmBinning*N@Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
],
FHMMmode===FHMMPhotonByPhoton,
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,FPMLHForwardBackwardiPeqFromK[N@Km],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPMLHForwardBackward[N@Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
]
,True,(Message[FHMMViterbi::noinit];Return[$Failed])
];
statetrajectory
]
FHMMForwardBackward[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[FHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FHMMForwardBackward[Km]
]


FHMMSimulatePhotonByPhotonTrace[photonrates_?FNumericMatrixQ,stateTraj:{{_?NumericQ ,_?NumericQ }..}]:=Module[
{
distL,kL=Total[photonrates] ,choiceL,state,photonTraj={},ft,t,dt,lt,color,channelcount
 },
channelcount=Length[photonrates];
distL=Map[ExponentialDistribution,kL]; (* distributions of escape times*)
choiceL=photonrates\[Transpose];
photonTraj=First@Last@Reap[
lt=stateTraj[[1,1]];
Do[
state=stateTraj[[itr,2]];
dt=RandomVariate[distL[[state]]];
t=stateTraj[[itr,1]]+dt;
dt=(stateTraj[[itr,1]]-lt)+dt;
ft=stateTraj[[itr+1,1]];
While[t<ft,
color=RandomChoice[choiceL[[state]]->Range[channelcount]];
Sow[{dt,color}];
lt=t;
dt=RandomVariate[distL[[state]]];
t+=dt;
];
,{itr,1,Length[stateTraj]-1}
];
];
{photonTraj,stateTraj}
]


(*
FHMMSimulatePhotonByPhotonTrace[photonrates:{{_?NumericQ..},{_?NumericQ..}},kMatrix_?FNumericSquareMatrixQ,pini:{_?NumericQ..},t_]:=Module[
{channelcount,statecount,it=0,transition,
distL,kL=-Diagonal[kMatrix]+Total[photonrates] ,choiceL,state,photonTraj={},stateTraj,peqL,tau=0,dt
 },
channelcount=Length[photonrates];
statecount=Length[pini];
distL=Map[ExponentialDistribution,kL]; (* distributions of escape times*)
choiceL=Table[Join[photonrates[[All,ns]],kMatrix[[All,ns]]]/.x_/;x<0\[Rule]0,{ns,1,Length[pini]}];
state=RandomChoice[pini\[Rule]Range[Length[pini]]];(* set initial state values*)
stateTraj={{0,state}};
it=tau=RandomVariate[distL[[state]]];(* time of the first transition*)
photonTraj=First@Last@Reap[
While[it<t,
transition=RandomChoice[choiceL[[state]]\[Rule]Range[channelcount+statecount]];
If[transition\[LessEqual]channelcount
,(Sow[{tau,transition}];tau=0)
,(state=transition-channelcount;(*AppendTo[stateTraj,{it,stateTraj[[-1,2]]}]*);AppendTo[stateTraj,{it,state}])];
dt=RandomVariate[distL[[state]]];
tau+=dt;
it+=dt;
]
];
AppendTo[stateTraj,{it,state}];
{photonTraj,stateTraj}
]
*)



FHMMSimulatePhotonByPhotonTrace[photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,pini:{_?NumericQ..},t_]:=Module[
{},
(*FPSimulatePhotonTrace[N@Flatten@kMatrix,N@photonrates[[1]],N@photonrates[[2]],N@pini,N@t,0,0.]*)
FPSimulatePhotonTrace2[N@t,0,0.,N@kMatrix,N@pini,N@photonrates]
]



FHMMSimulatePhotonByPhotonTrace[params:{{photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,pini:{_?NumericQ..},t_}..}]:=Module[
{},
FPSimulatePhotonTraceParallel[0,0.,N@params[[All,2]],N@Transpose[params[[All,3]]],N@params[[All,1]],N@params[[All,4]]]
]


FHMMSimulatePhotonByPhotonTrace[photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,t_]:=Module[{peq},
peq=NullSpace[kMatrix][[1]];
peq/=Total[peq];
FHMMSimulatePhotonByPhotonTrace[photonrates,kMatrix,peq,t]
]


FHMMSimulatePhotonByPhotonTrace[params:{{photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,t_}..}]:=Module[
{peq},
peq=Map[NullSpace[#][[1]]&,params[[All,2]]];
peq=Map[#/Total[#]&,peq];
FPSimulatePhotonTraceParallel[0,0.,N@params[[All,2]],N@Transpose[peq],N@params[[All,1]],N@params[[All,4]]]
]



FHMMSimulateBinnedTrace[photonrates_?(MatrixQ[#,NumericQ]&),kMatrix_?FNumericSquareMatrixQ,pini:{_?NumericQ..},t_?NumericQ,binning_?NumericQ]:=Module[
{},
FPSimulatePhotonTrace2[N@t,1,N@binning,N@kMatrix,N@pini,N@photonrates]
]


FHMMSimulateBinnedTrace[params:{{photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,pini:{_?NumericQ..},t_}..},binning_?NumericQ]:=Module[
{},
FPSimulatePhotonTraceParallel[1,N@binning,N@params[[All,2]],N@Transpose[params[[All,3]]],N@params[[All,1]],N@params[[All,4]]]
]


FHMMSimulateBinnedTrace[photonrates_?(MatrixQ[#,NumericQ]&),kMatrix_?FNumericSquareMatrixQ,t_,binning_]:=Module[{peq},
peq=NullSpace[kMatrix][[1]];
peq/=Total[peq];
FHMMSimulateBinnedTrace[photonrates,kMatrix,peq,t,binning]
]


FHMMSimulateBinnedTrace[params:{{photonrates_?FNumericMatrixQ,kMatrix_?FNumericSquareMatrixQ,t_}..},binning_]:=Module[
{peq},
peq=Map[NullSpace[#][[1]]&,params[[All,2]]];
peq=Map[#/Total[#]&,peq];
FPSimulatePhotonTraceParallel[1,N@binning,N@params[[All,2]],N@Transpose[peq],N@params[[All,1]],N@params[[All,4]]]
]


FHMMBinPhotonByPhotonTrace[photonTraj:{{_?NumericQ ,_Integer }..},dt_?NumericQ,channelcount_Integer:2]:=FPBinPhotonByPhotonTrace[N@photonTraj[[All,1]],photonTraj[[All,2]],N@dt,channelcount](*Module[{(*data=photonTraj,*)mcs,mint,maxt},


data[[All,1]]=Accumulate[photonTraj[[All,1]]];
mcs=Table[Cases[data,{_,c,___}][[All,1]],{c,channelcount}];

mint=data[[1,1]];
maxt=data[[-1,1]]+dt;
mcs=Map[BinCounts[#,{mint,maxt,dt}]&,mcs];
mcs\[Transpose]

]*)



FGetPhotonData[{tstart_?NumericQ,tend_?NumericQ},routes:FRouteList]:=FPGetPhotonInformation[N@tstart,N@tend,FRouteListToByte[routes]]


FGetPhotonDataRaw[{tstart_?NumericQ,tend_?NumericQ},routes:FRouteList]:=FPGetPhotonInformation2[N@tstart,N@tend,FRouteListToByte[routes]]


FExportTTTRToH5[filename_String,{t1_,t2_},routes:FRouteList]:=Block[{data},
data=FGetPhotonDataRaw[{t1,t2},routes];
If[FileExtension[filename]=!= "h5",Return[$Failed]];
Export[filename,
{
"InterPhotonTimes"->{
"Data"-> data[[2,1]],
"DataFormat"->"UnsignedInteger32",
"Attributes"->{"MacroTimeUnitInPicoSeconds"->("MacroTimeToPicoseconds"/.data[[1]]),"StartTimeInSeconds"->("StartTime"/.data[[1]])}
},
"Detectors"->{
"Data"-> data[[2,2]],
"DataFormat"->"UnsignedInteger8"
}
,
"MicroTimes"->{
"Data"-> data[[2,3]],
"DataFormat"->"UnsignedInteger16",
"Attributes"->{"MicroTimeTimeUnitInPicoSeconds"->("MicroTimeToPicoseconds"/.data[[1]])}
}
}
]
]


FHMMGetPhotonByPhotonTraceFromTTTR[{tstart_?NumericQ,tend_?NumericQ},routes:{FRouteList..}:{FGetAcceptorRoutes[],FGetDonorRoutes[]}]:=
Module[{r,rall,data},
r=FExpandRoutelist/@routes;
rall=Total[r];
If[!MatchQ[rall,FRouteList],Return[$Failed]];(*At least one detector channel is selected in more than one Routelist*)
data=FPGetPhotonInformation[N@tstart,N@tend,FRouteListToByte[rall]][[2,All,1;;2]];
r=Map[Flatten@Position[#,1]&,r];
r=Join@@Table[Map[(#->i)&,r[[i]]],{i,Length[r]}];
data[[All,2]]=data[[All,2]]/.r;
data
]

FHMMGetBinnedTraceFromTTTR[Tbinning_?NumericQ,{tstart_?NumericQ,tend_?NumericQ},routes:{FRouteList..}:{FGetAcceptorRoutes[],FGetDonorRoutes[]}]:=
Round[FMCStrace[routes,Tbinning*1000.,tstart,tend, FOutput->FData][[All,All,2]]]\[Transpose]


FCalcAV[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4&),dyeparams:{{{_?NumericQ,_?NumericQ,_?NumericQ},_?NumericQ,_?NumericQ,{_?NumericQ,_?NumericQ,_?NumericQ}}..},gridspaceing_?NumericQ]:=Module[{},

Transpose/@FPCalcAV[N@Transpose@atoms,N@dyeparams[[All,1]],N@dyeparams[[All,2]],N@dyeparams[[All,3]],N@dyeparams[[All,4]],N@gridspaceing]
]
FCalcAV[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4&),dyeattachmentpoint:{_?NumericQ,_?NumericQ,_?NumericQ},linkerL_?NumericQ,linkerD_?NumericQ,dyeradii:{_?NumericQ,_?NumericQ,_?NumericQ},gridspaceing_?NumericQ]:=FCalcAV[atoms,{{dyeattachmentpoint,linkerL,linkerD,dyeradii}},gridspaceing][[1]]


FCalcAVMinLinkerLength[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4&),dyeparams:{{{_?NumericQ,_?NumericQ,_?NumericQ},_?NumericQ,_?NumericQ,_?NumericQ}..},gridspaceing_?NumericQ]:=Module[{},

Transpose/@FPCalcMinLinkerLength[N@Transpose@atoms,N@dyeparams[[All,1]],N@dyeparams[[All,2]],N@dyeparams[[All,3]],N@dyeparams[[All,4]],N@gridspaceing]
]
FCalcAVMinLinkerLength[atoms_?(FNumericMatrixQ[#] && Dimensions[#][[2]]==4&),dyeattachmentpoint:{_?NumericQ,_?NumericQ,_?NumericQ},linkerL_?NumericQ,linkerD_?NumericQ,dyeradius_?NumericQ,gridspaceing_?NumericQ]:=FCalcAVMinLinkerLength[atoms,{{dyeattachmentpoint,linkerL,linkerD,dyeradius}},gridspaceing][[1]]


FTRBPInit[minmaxpos_?FNumericMatrixQ,kofflist_List,prlist_?FNumericMatrixQ,pDifflist_List,statelist_List]:=FPTRBPInit[N@minmaxpos,N@kofflist,N@prlist,N@pDifflist,N@Transpose[Flatten/@statelist]]


FTRBPGetKMatrix[]:=FPTRBPGetKMatrix[]
FTRBPGetPeq[]:=FPTRBPGetPeq[]
FTRBPGetPeqFast[kofflist_?FNumericMatrixQ,prlist_?FNumericMatrixQ]:=FPTRBPGetPeqFast[N@kofflist,N@prlist]


FTRBPSimulatePhotonByPhotonTrace[params:{{(*photonrates*)_?FNumericMatrixQ,(*pini:*){_?NumericQ..},(*t*)_}..}]:=Module[
{},
FPTRBPSimulatePhotonTraceParallel[0,0.,N@Transpose[params[[All,2]]],N@params[[All,1]],N@params[[All,3]]]
]
FTRBPSimulateBinnedTrace[params:{{(*photonrates*)_?FNumericMatrixQ,(*pini:*){_?NumericQ..},(*t*)_}..},binning_]:=Module[
{},
FPTRBPSimulatePhotonTraceParallel[1,binning,N@Transpose[params[[All,2]]],N@params[[All,1]],N@params[[All,3]]]
]


FFretHmmBinning=1.;
FFretHMMmode=None;
FFretHMMTrajectoryCount=0;
FFretHMMStateCount=0;
FFretHMMGlobalRates=False;
FFretHMMFmean={1.,1.};
FFretHMMmu=0.;


FFretHMMInitWithBinnedData[trlist:{{{_?NumericQ ,_?NumericQ }..}..},Tbinning_?NumericQ]:=Module[{unitv},

FFretHmmBinning=Tbinning;
FPFretHmmClearTrajectoryList[];
unitv=ConstantArray[1.,2];
Map[FPFretHmmAppendTrajectory[Round@Flatten@#]&,trlist];
FFretHMMmode=FHMMBinned;
FFretHMMTrajectoryCount=Length[trlist];
FFretHMMStateCount=0;
]


FFretHMMInitWithPhotonByPhotonData[trlist:{{{_?NumericQ ,_Integer }..}..}]:=Module[{unitv,tr},
FMLHClearBurstList[];
unitv=ConstantArray[1,2];
Map[FMLHAppendToBurstList[(tr={{unitv,unitv,unitv,unitv},#};tr[[2,All,2]]-=1;tr)]&,trlist];
FFretHMMmode=FHMMPhotonByPhoton;
FFretHMMTrajectoryCount=Length[trlist];
FFretHMMStateCount=0;
]


FFretHMMSetPhotonRates[rateparams:{{{{_?NumericQ, _?NumericQ, _?NumericQ}..}, _?NumericQ, _?NumericQ}..}]:=Module[{nstates,Fmean,mu,nu,bgA,bgD},
nstates=Length[rateparams[[1,1]]];
Fmean=N@FFretHmmBinning*Flatten@rateparams[[All,1,All,1]];
mu=N@Flatten@rateparams[[All,1,All,2]];
nu=N@Flatten@rateparams[[All,1,All,3]];
bgA=N@FFretHmmBinning*Flatten@Map[ConstantArray[#,nstates]&,rateparams[[All,2]]];
bgD=N@FFretHmmBinning*Flatten@Map[ConstantArray[#,nstates]&,rateparams[[All,3]]];
nstates=Length[rateparams[[1,1]]];

FFretHMMGlobalRates=False;
Which[
FFretHMMmode===FHMMBinned,FPFretHmmSetPhotonRates[bgA,bgD,Fmean,mu,nu,nstates],
FFretHMMmode===FHMMPhotonByPhoton,Return[$Failed],
True,(Message[FHMMSetPhotonRates::erroptval];Return[$Failed])
];
FFretHMMStateCount=nstates;
]
(*FFretHMMSetPhotonRates[rateparams:{Fmean_?NumericQ, mu_?NumericQ,nu_?NumericQ, bgA_?NumericQ, bgD_?NumericQ}]:=Module[{},

FFretHMMSetPhotonRates[ConstantArray[rateparams,FFretHMMTrajectoryCount]];
FFretHMMGlobalRates=True;
FFretHMMFmean=Fmean;
FFretHMMmu=mu;
FFretHMMnu=nu;
FFretHMMbgA=bgA;
FFretHMMbgD=bgD;
]*)


FFretHMMSetPinPfin[pinpfin:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[pinpfin[[1,1]]];
If[AnyTrue[pinpfin,Length[#]!=nstates&,2],Return[$Failed]];
FFretHMMGlobalRates=False;
Which[
FFretHMMmode===FHMMBinned
,FPFretHmmSetPinPfin[N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
FFretHMMmode===FHMMPhotonByPhoton
,FPMLHSetPinPfin[N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
True,$Failed
]
]

FFretHMMSetPinPfin[{pin:{_?NumericQ..}, pfin:{_?NumericQ..}}]:=Module[{},
If[Length[pin]!=FFretHMMStateCount || Length[pfin]!=FFretHMMStateCount,Return[$Failed]];
FFretHMMSetPinPfin[ConstantArray[{pin,pfin},FFretHMMTrajectoryCount]];

]



Options[FFretHMMLogLikelihood]={FHMMpinpfin->FHMMPeqOne};
FFretHMMLogLikelihood[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{lh},
If[Length[Km]!=FFretHMMStateCount,(Message[FHMMLogLikelihood::dimerr];Return[$Failed])];
Which[FFretHMMmode===FHMMBinned,
lh=Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FFretHMMGlobalRates, FPFretHmmGetLikelihoodPeqFromK[FFretHmmBinning*N@FFretHMMbgA,FFretHmmBinning*N@FFretHMMbgD,FFretHmmBinning*N@FFretHMMFmean,N@FFretHMMmu,N@FFretHMMnu,FFretHmmBinning*N@Flatten@Km],FPFretHmmGetLikelihoodPeqFromK[FFretHmmBinning*N@Flatten@Km,Length[Km]]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPHmmGetLikelihood[FFretHmmBinning*N@Flatten@Km,Length[Km]],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,FFretHMMmode===FHMMPhotonByPhoton,
lh=-
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,FPMLHGetLikelihoodPeqFromK[N@FHMMNa,N@FHMMNd,N@Flatten@Km],FPMLHGetLikelihoodPeqFromK[N@Km]],OptionValue[FHMMpinpfin]===FHMMTraceWise
,If[FHMMGlobalRates,FPMLHGetLikelihood[N@FHMMNa,N@FHMMNd,N@Flatten@Km],FPMLHGetLikelihood[N@Flatten@Km,Length[Km]]],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,True,(Message[FHMMLogLikelihood::noinit];Return[$Failed])
];
lh
]
FFretHMMLogLikelihood[Km_?FNumericSquareMatrixQ, rateparams:{{{{_?NumericQ, _?NumericQ, _?NumericQ}..}, _?NumericQ, _?NumericQ}..},opts:OptionsPattern[]]:=Module[{lh},
If[FFretHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FFretHMMLogLikelihood[Km]
]


FretBinnedViterbiPeqFromK[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FFretPHmmViterbiPeqFromK[FFretHmmBinning*N@Flatten@Km,Length[Km]]/.FDwell[t_,s_,dt_,p___]:>FDwell[FFretHmmBinning*t,s,FFretHmmBinning*dt,p]]
FretBinnedViterbi[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FFretPHmmViterbi[FFretHmmBinning*N@Flatten@Km,Length[Km]]/.FDwell[t_,s_,dt_,p___]:>FDwell[FFretHmmBinning*t,s,FFretHmmBinning*dt,p]]



Options[FFretHMMViterbi]={FHMMpinpfin->FHMMPeqOne};
FFretHMMViterbi[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=FFretHMMStateCount,(Message[FHMMViterbi::dimerr];Return[$Failed])];
Which[
FFretHMMmode===FHMMBinned
,statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FFretHMMGlobalRates,FretBinnedViterbiPeqFromK[Km],BinnedViterbiPeqFromK[Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FretBinnedViterbi[Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
],
FFretHMMmode===FHMMPhotonByPhoton,
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,FPMLHViterbiPeqFromK[N@Km],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPMLHViterbi[N@Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
]
,True,(Message[FHMMViterbi::noinit];Return[$Failed])
];
statetrajectory
]
FFretHMMViterbi[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[FFretHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FFretHMMViterbi[Km]
]


Options[FFretHMMForwardBackward]={FHMMpinpfin->FHMMPeqOne};
FFretHMMForwardBackward[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=FFretHMMStateCount,(Message[FHMMViterbi::dimerr];Return[$Failed])];
Which[
FFretHMMmode===FHMMBinned
,statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FFretHMMGlobalRates,$False,FPFretHmmForwardBackwardPeqFromK[FFretHmmBinning*N@Flatten@Km,Length[Km]]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPFretHmmForwardBackward[FFretHmmBinning*N@Flatten@Km,Length[Km]],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
],
FFretHMMmode===FHMMPhotonByPhoton,
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,FPMLHForwardBackwardiPeqFromK[N@Flatten@Km,Length[Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPMLHForwardBackward[N@Flatten@Km,Length[Km]],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
]
,True,(Message[FHMMViterbi::noinit];Return[$Failed])
];
statetrajectory
]
FFretHMMForwardBackward[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[FFretHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FFretHMMForwardBackward[Km]
]


FFretHMMSimulateBinnedTrace[Km_?FNumericSquareMatrixQ, rateparams:{{_?NumericQ, _?NumericQ, _?NumericQ, _?NumericQ, _?NumericQ}..},Smax_Integer,t_?NumericQ, binning_?NumericQ]:=Module[{Fmean,mu,nu,bgA,bgD,length,dat},
{Fmean,mu,nu,bgA,bgD}=rateparams\[Transpose];
length=Round[t/binning];
dat=FPFretHmmSimulateTrajectoryPeqFromK[length,Smax,N@binning*Flatten@bgA,N@binning*Flatten@bgD,N@binning*Flatten@Fmean,N@Flatten@mu,N@Flatten@nu,binning*N@Flatten@Km];
{dat[[All,1;;2]],dat[[All,3]]}
]


F1DHMMBinning=1.;
F1DHMMmode=None;
F1DHMMTrajectoryCount=0;
F1DHMMStateCount=0;
F1DHMMGlobalPobs=False;
F1DHMMPobs={};


F1DHMMInit[observations:{{_Integer..}..},Tbinning_?NumericQ]:=Module[{},

F1DHMMBinning=Tbinning;
FPHmm1DClearTrajectoryList[];

Map[FPHmm1DAppendTrajectory[#]&,observations];
F1DHMMTrajectoryCount=Length[observations];
F1DHMMStateCount=0;
]


F1DHMMSetPobs[pobs:{_?(MatrixQ[#,NumericQ]&) ..}]:=Module[{},
FPHmm1DClearPobsList[];
Map[FPHmm1DAppendPobs,N@pobs];
F1DHMMStateCount=Length[pobs[[1]]];
F1DHMMGlobalPobs=False;
]
F1DHMMSetPobs[pobs_?(MatrixQ[#,NumericQ]&)]:=Module[{},
FPHmm1DClearPobsList[];
Do[FPHmm1DAppendPobs[N@pobs],{i,F1DHMMTrajectoryCount}];
F1DHMMStateCount=Length[pobs];
F1DHMMGlobalPobs=True;
F1DHMMPobs=pobs;
]


F1DHMMSetPinPfin[pinpfin:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[pinpfin[[1,1]]];
If[AnyTrue[pinpfin,Length[#]!=nstates&,2],Return[$Failed]];
F1DHMMGlobalPobs=False;
FPHmm1DAppendPobs[N@pinpfin[[All,1]],N@pinpfin[[All,2]]]
]

F1DHMMSetPinPfin[{pin:{_?NumericQ..}, pfin:{_?NumericQ..}}]:=Module[{},
If[Length[pin]!=F1DHMMStateCount || Length[pfin]!=F1DHMMStateCount,Return[$Failed]];
F1DHMMSetPinPfin[ConstantArray[{pin,pfin},F1DHMMTrajectoryCount]];

]



Options[F1DHMMLogLikelihood]={FHMMpinpfin->FHMMPeqOne};
F1DHMMLogLikelihood[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{lh},
If[Length[Km]!=F1DHMMStateCount,(Message[F1DHMMLogLikelihood::dimerr];Return[$Failed])];
lh=Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[F1DHMMGlobalPobs, FPHmm1DGetLikelihoodPeqFromKGlobalPobs[F1DHMMBinning*N@Km,N@F1DHMMPobs],FPHmm1DGetLikelihoodPeqFromK[F1DHMMBinning*N@Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPHmm1DGetLikelihood[F1DHMMBinning*N@Km],
True
,(Message[F1DHMMLogLikelihood::erroptval];Return[$Failed])
];
lh
]
F1DHMMLogLikelihood[Km_?FNumericSquareMatrixQ, pobs:{_?(MatrixQ[#,NumericQ]&) ..}|_?(MatrixQ[#,NumericQ]&),opts:OptionsPattern[]]:=Module[{lh},
If[F1DHMMSetPobs[pobs]===$Failed,Return[$Failed]];
F1DHMMLogLikelihood[Km]
]


F1DHMMGetLogLikelihoodList[]:= FPHmm1DGetLikelihoodList[]


F1DHMMBinnedViterbiPeqFromK[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmm1DViterbiPeqFromK[F1DHMMBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[F1DHMMBinning*t,s,F1DHMMBinning*dt,p]]
F1DHMMBinnedViterbi[Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPHmm1DViterbi[F1DHMMBinning*N@Km]/.FDwell[t_,s_,dt_,p___]:>FDwell[F1DHMMBinning*t,s,F1DHMMBinning*dt,p]]



Options[F1DHMMViterbi]={FHMMpinpfin->FHMMPeqOne};
F1DHMMViterbi[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=F1DHMMStateCount,(Message[F1DHMMViterbi::dimerr];Return[$Failed])];
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[F1DHMMGlobalPobs,F1DHMMBinnedViterbiPeqFromK[Km],F1DHMMBinnedViterbiPeqFromK[Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,F1DHMMBinnedViterbi[Km],
True
,(Message[F1DHMMViterbi::erroptval];Return[$Failed])
];
statetrajectory
]
F1DHMMViterbi[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[F1DHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
F1DHMMViterbi[Km]
]


Options[F1DHMMForwardBackward]={FHMMpinpfin->FHMMPeqOne};
F1DHMMForwardBackward[Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=F1DHMMStateCount,(Message[F1DHMMViterbi::dimerr];Return[$Failed])];
statetrajectory=Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[F1DHMMGlobalPobs,$False,FPHmm1DForwardBackwardPeqFromK[F1DHMMBinning*N@Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPHmm1DForwardBackward[F1DHMMBinning*N@Km],
True
,(Message[F1DHMMViterbi::erroptval];Return[$Failed])
];
statetrajectory
]
F1DHMMForwardBackward[Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[F1DHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
F1DHMMForwardBackward[Km]
]


FHmmBinning=1.;
FHMMmode=None;
FHMMTrajectoryCount=0;
FHMMStateCount=0;
FHMMGlobalRates=False;
FHMMNa={1,1};
FHMMNd={1,1};


FGHMMSetNumberOfModels[modelsize_Integer]:=FPGHmmSetNumberOfModels[modelsize]


FGHMMInitWithBinnedData[mi_Integer, trlist:{{{_?NumericQ ,_?NumericQ }..}..},Tbinning_?NumericQ]:=Module[{unitv,result},

FHmmBinning=Tbinning;
FPGHmmClearTrajectoryList[mi-1];
unitv=ConstantArray[1.,2];
result=Map[FPGHmmAppendTrajectory[mi-1, Round@Flatten@#,unitv,unitv,unitv,unitv]&,trlist];
FHMMmode=FHMMBinned;
FGHMMTrajectoryCount[mi]=Length[trlist];
FHMMStateCount=0;
result
]


FGHMMInitWithPhotonByPhotonData[trlist:{{{_?NumericQ ,_Integer }..}..}]:=Module[{unitv,tr},
FMLHClearBurstList[];
unitv=ConstantArray[1,2];
Map[FMLHAppendToBurstList[(tr={{unitv,unitv,unitv,unitv},#};tr[[2,All,2]]-=1;tr)]&,trlist];
FHMMmode=FHMMPhotonByPhoton;
FHMMTrajectoryCount=Length[trlist];
FHMMStateCount=0;
]





FGHMMSetPhotonRates[mi_Integer,rates:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[rates[[1,1]]];
If[AnyTrue[rates,Length[#]!=nstates&,2],(Message[FHMMSetPhotonRates::dimerr];Return[$Failed])];
FHMMGlobalRates=False;
Which[
FHMMmode===FHMMBinned,FPGHmmSetPhotonRates[mi-1,N@FHmmBinning*Flatten@rates[[All,1]],N@FHmmBinning*Flatten@rates[[All,2]],Length@rates[[1,1]]],
FHMMmode===FHMMPhotonByPhoton,FMLHSetPhotonRates[rates],
True,(Message[FHMMSetPhotonRates::erroptval];Return[$Failed])
];
FHMMStateCount=nstates;
]
FGHMMSetPhotonRates[mi_Integer,{nA:{_?NumericQ..}, nD:{_?NumericQ..}}]:=Module[{},
If[Length[nA]!=Length[nD] ,(Message[FHMMSetPhotonRates::dimerr];Return[$Failed])];
FGHMMSetPhotonRates[mi,ConstantArray[{nA,nD},FGHMMTrajectoryCount[mi]]];
FHMMGlobalRates=True;
FHMMNa=nA;
FHMMNd=nD;
]


FGHMMSetPinPfin[mi_Integer,pinpfin:{{{_?NumericQ..},{_?NumericQ..}}..}]:=Module[{nstates},
nstates=Length[pinpfin[[1,1]]];
If[AnyTrue[pinpfin,Length[#]!=nstates&,2],Return[$Failed]];
FHMMGlobalRates=False;
Which[
FHMMmode===FHMMBinned
,FPGHmmSetPinPfin[mi-1, N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
FHMMmode===FHMMPhotonByPhoton
,FPMLHSetPinPfin[N@Flatten@pinpfin[[All,1]],N@Flatten@pinpfin[[All,2]],Length@pinpfin[[1,1]]],
True,$Failed
]
]

FGHMMSetPinPfin[mi_Integer,{pin:{_?NumericQ..}, pfin:{_?NumericQ..}}]:=Module[{},
If[Length[pin]!=FHMMStateCount || Length[pfin]!=FHMMStateCount,Return[$Failed]];
FGHMMSetPinPfin[mi,ConstantArray[{pin,pfin},FGHMMTrajectoryCount[mi]]];

]






Options[FGHMMLogLikelihood]={FHMMpinpfin->FHMMPeqOne};
FGHMMLogLikelihood[mi_Integer,Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{lh},
If[Length[Km]!=FHMMStateCount,(Message[FHMMLogLikelihood::dimerr];Return[$Failed])];
Which[FHMMmode===FHMMBinned,
lh=Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates, FPGHmmGetLikelihoodPeqFromK[mi-1,FHmmBinning*N@FHMMNa,FHmmBinning*N@FHMMNd,FHmmBinning*N@Flatten@Km],FPGHmmGetLikelihoodPeqFromK[mi-1,FHmmBinning*N@Flatten@Km,Length[Km]]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPGHmmGetLikelihood[mi-1, FHmmBinning*N@Flatten@Km,Length[Km]],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,FHMMmode===FHMMPhotonByPhoton,
lh=-
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,FPMLHGetLikelihoodPeqFromK[N@FHMMNa,N@FHMMNd,N@Flatten@Km],FPMLHGetLikelihoodPeqFromK[N@Flatten@Km,Length[Km]]],OptionValue[FHMMpinpfin]===FHMMTraceWise
,If[FHMMGlobalRates,FPMLHGetLikelihood[N@FHMMNa,N@FHMMNd,N@Flatten@Km],FPMLHGetLikelihood[N@Flatten@Km,Length[Km]]],
True
,(Message[FHMMLogLikelihood::erroptval];Return[$Failed])
]
,True,(Message[FHMMLogLikelihood::noinit];Return[$Failed])
];
lh
]
FGHMMLogLikelihood[mi_Integer,Km_?FNumericSquareMatrixQ, photonrates:{{{_?NumericQ..},{_?NumericQ..}}..}|{{_?NumericQ..}, {_?NumericQ..}},opts:OptionsPattern[]]:=Module[{lh},
If[FGHMMSetPhotonRates[mi,photonrates]===$Failed,Return[$Failed]];
FGHMMLogLikelihood[mi,Km]
]


BinnedViterbiPeqFromK[mi_Integer,Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPGHmmViterbiPeqFromK[mi-1, FHmmBinning*N@Flatten@Km,Length[Km]]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]
BinnedViterbi[mi_Integer, Km_?FNumericSquareMatrixQ]:=Module[{tr},tr=FPGHmmViterbi[mi-1 ,FHmmBinning*N@Flatten@Km,Length[Km]]/.FDwell[t_,s_,dt_,p___]:>FDwell[FHmmBinning*t,s,FHmmBinning*dt,p]]



Options[FGHMMViterbi]={FHMMpinpfin->FHMMPeqOne};
FGHMMViterbi[mi_Integer,Km_?FNumericSquareMatrixQ,opts:OptionsPattern[]]:=Module[{statetrajectory},
If[Length[Km]!=FHMMStateCount,(Message[FHMMViterbi::dimerr];Return[$Failed])];
Which[
FHMMmode===FHMMBinned
,statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,If[FHMMGlobalRates,BinnedViterbiPeqFromK[mi,FHMMNa,FHMMNd,Km],BinnedViterbiPeqFromK[mi,Km]],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,BinnedViterbi[Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
],
FHMMmode===FHMMPhotonByPhoton,
statetrajectory=
Which[
OptionValue[FHMMpinpfin]===FHMMPeqOne
,FPMLHViterbiPeqFromK[N@Km],
OptionValue[FHMMpinpfin]===FHMMTraceWise
,FPMLHViterbi[N@Km],
True
,(Message[FHMMViterbi::erroptval];Return[$Failed])
]
,True,(Message[FHMMViterbi::noinit];Return[$Failed])
];
statetrajectory
]
FGHMMViterbi[mi_Integer,Km_?FNumericSquareMatrixQ, photonrates_,opts:OptionsPattern[]]:=Module[{lh},
If[FHMMSetPhotonRates[photonrates]===$Failed,Return[$Failed]];
FHMMViterbi[Km]
]


FTSSetNumberOfSpecies[SpeciesNumber_Integer]:=FTSSetNumberOfSpeciesP[SpeciesNumber]
FTSGetNumberOfSpecies[]:=FTSGetNumberOfSpeciesP[]

Options[FTSSimulateParticleDiffusion]={Method->"1D"};
FTSSimulateParticleDiffusion[SpeciesIndex_Integer,ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleConcentration_?NumberQ,SimulationTime_?NumberQ,TimeStep_?NumberQ,NewParticleDeltaT_Integer,MinimalTrajectoryLength_Integer,RMinThreshold_?NumberQ,RMaxThreshold_?NumberQ,opts:OptionsPattern[]]:=If[DiffConstant>0,
FTSSimulateParticleDiffusionP[SpeciesIndex-1,N@ShpereRadius,N@DiffConstant,N@ParticleConcentration,N@SimulationTime,N@TimeStep,NewParticleDeltaT,MinimalTrajectoryLength,N@RMinThreshold,N@RMaxThreshold,Which[
OptionValue[Method]==="1D",1,OptionValue[Method]==="2D",2,True,2]]
,0]
FTSSimulateParticleDiffusion[SpeciesIndex_Integer,ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleConcentration_?NumberQ,SimulationTime_?NumberQ,TimeStep_?NumberQ,NewParticleDeltaT_Integer,MinimalTrajectoryLength_Integer,RMinThreshold_?NumberQ,opts:OptionsPattern[]]:=FTSSimulateParticleDiffusion[SpeciesIndex,ShpereRadius,DiffConstant,ParticleConcentration,SimulationTime,TimeStep,NewParticleDeltaT,MinimalTrajectoryLength,RMinThreshold,ShpereRadius,opts]


 FTSSimulateParticleDiffusionInClosedSphere[SpeciesIndex_Integer,ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleNumber_Integer,SimulationTime_?NumberQ,TimeStep_?NumberQ,RMaxThreshold_?NumberQ, WallStickyness_?NumberQ]:=FTSSimulateParticleDiffusionInClosedSphereP[SpeciesIndex-1,N@ShpereRadius,N@Abs@DiffConstant,ParticleNumber,N@SimulationTime,N@TimeStep,N@RMaxThreshold, N@WallStickyness]


FTSSimulateParticleDiffusionInClosedCylinder[SpeciesIndex_Integer,CylinderRadius_?NumberQ,CylinderHalfLength_?NumberQ,DiffConstant_?NumberQ,ParticleNumber_Integer,SimulationTime_?NumberQ,TimeStep_?NumberQ,RMaxThreshold_?NumberQ, WallStickyness_?NumberQ]:=FTSSimulateParticleDiffusionInClosedCylinderP[SpeciesIndex-1,N@CylinderRadius,N@CylinderHalfLength,N@Abs@DiffConstant,ParticleNumber,N@SimulationTime,N@TimeStep,N@RMaxThreshold, N@WallStickyness]


FTSSimulateImmobilizedParticle[SimulationTime_?NumberQ,TimeStep_?NumberQ]:=FTSSimulateImobilizedParticleP[N@SimulationTime,N@TimeStep]


FTSSimulateFRETpair[trajectory:{_?NumericQ..},R0_?NumericQ,TimeStep_?NumericQ]:=FTSSimulateFRETpairP[N@trajectory,N@R0,N@TimeStep]


FTSNewParticleConcentration[ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleConcentration_?NumberQ,radius_?NumberQ,time_?NumberQ]:=If[radius>ShpereRadius,ParticleConcentration,
If[time<=0,0,FTSProbabilityDensityP[N@ShpereRadius,N@DiffConstant,N@ParticleConcentration,N@radius,N@time]/(4\[Pi] radius^2)]]
FTSMeanNewParticleNumberInSphere[ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleConcentration_?NumberQ,time_?NumberQ]:=FTSMeanParticelNumberEnteringTheSphereP[N@ShpereRadius,N@DiffConstant,N@ParticleConcentration,N@time]

FTSRandomPositionInSphere[ShpereRadius_?NumberQ,DiffConstant_?NumberQ,ParticleConcentration_?NumberQ,time_?NumberQ]:=FTSRandomPositionInSphereP[N@ShpereRadius,N@DiffConstant,N@ParticleConcentration,N@time]


FTSGetTrajectories[SpeciesIndex_Integer,Span[trajecIndex1_Integer,trajecIndex2_Integer],rmax_?NumberQ, rstep_Integer]:=FTSGetTrajectories2P[SpeciesIndex-1,trajecIndex1-1,trajecIndex2,N@rmax,rstep];
FTSGetTrajectories[SpeciesIndex_Integer,Span[trajecIndex1_Integer,All],rmax_?NumberQ,rstep_Integer]:=FTSGetTrajectories[SpeciesIndex,Span[trajecIndex1,-1],rmax,rstep];




FTSDistanceTrajectory[tr_]:=Module[{\[CapitalDelta],f},
\[CapitalDelta]=Global`TsTimestep/.tr[[1]];
f[dat_]:=Module[{d=dat[[2]]},
d[[All,2]]=Map[Norm,d[[All,2]]];
d[[All,1]]=(\[CapitalDelta] d[[All,1]]+dat[[1]])10^-6;
d
];
Map[f,tr[[2]]]
]
FTSIntensityTrajectory[tr_,I0_,w0_,z0_]:=Module[{\[CapitalDelta],f,intensity},
\[CapitalDelta]=Global`TsTimestep/.tr[[1]];
intensity[{r_,z_}]:=I0 Exp[-((2.r^2)/w0^2)-(2.z^2)/z0^2];
intensity[r_]:=I0 Exp[-((2.r^2)/w0^2)];
f[dat_]:=Module[{d=dat[[2]]},
d[[All,2]]=Map[intensity,d[[All,2]]];
d[[All,1]]=(\[CapitalDelta] d[[All,1]]+dat[[1]])10^-6;
d
];
Map[f,tr[[2]]]
]



FTSRateList={Repeated[_?NumberQ,FNumberOfRoutes]};

FTSGetRDistribution[speciesindex_Integer,binwidth_?NumberQ, bincount_Integer]:={Table[(i-0.5) binwidth,{i,bincount}],FTSGetRDistributionP[speciesindex-1,N@binwidth, bincount]}\[Transpose]
FTSGetNumberOfParticleTrajectory[speciesindex_Integer,binwidth_Integer, rmax_?NumberQ]:= FTSGetNumberOfParticleTrajectoryP[speciesindex-1,binwidth, rmax]


FTSSimulateStateTrajectories[{species_Integer,brightnesslist:{FTSRateList..},p0:{_?FRealNumberQ..},Kmatrix:_?(MatrixQ[#,FRealNumberQ]&)}]:=Module[{dim=Length[p0],escaperates,transitionprobs},
If[!(dim==Length[brightnesslist] && Dimensions[Kmatrix]=={dim,dim}),$Failed,
(
escaperates=Abs@Diagonal[Kmatrix];
transitionprobs=Kmatrix\[Transpose]-DiagonalMatrix[Diagonal[Kmatrix]];
transitionprobs=MapIndexed[If[#1==ConstantArray[0,Length@transitionprobs],UnitVector[Length@transitionprobs,#2[[1]]],#1]&,transitionprobs];
FTSSimulateStateTrajectoriesP[species-1,6,N@Flatten[FExpandRoutelist/@brightnesslist],N@p0,N@escaperates,N@Flatten@transitionprobs]
)
]
]

FTSSimulateStateTrajectories[{species_Integer,brightnesslist:{FTSRateList..},p0:{_?FRealNumberQ..},Kmatrix:_?(MatrixQ[#,FRealNumberQ]&),Kpowermatrix:_?(MatrixQ[#,FRealNumberQ]&)},w0_?FRealNumberQ,z0_?FRealNumberQ,rmax_?FRealNumberQ]:=Module[{dim=Length[p0],escaperates,transitionprobs,pescaperates,ptransitionprobs},
If[!(dim==Length[brightnesslist] && Dimensions[Kmatrix]=={dim,dim}),$Failed,
(

escaperates=Abs@Diagonal[Kmatrix];
transitionprobs=Kmatrix\[Transpose]-DiagonalMatrix[Diagonal[Kmatrix]];
transitionprobs=MapIndexed[If[#1==ConstantArray[0,Length@transitionprobs],UnitVector[Length@transitionprobs,#2[[1]]],#1]&,transitionprobs];
pescaperates=Abs@Diagonal[Kpowermatrix];

ptransitionprobs=Kpowermatrix\[Transpose]-DiagonalMatrix[Diagonal[Kpowermatrix]];
ptransitionprobs=MapIndexed[If[#1==ConstantArray[0,Length@ptransitionprobs],UnitVector[Length@ptransitionprobs,#2[[1]]],#1]&,ptransitionprobs];
FTSSimulateStateTrajectoriesPowerDependentP[species-1,6,N@Flatten[FExpandRoutelist/@brightnesslist],N@p0,N@escaperates,N@Flatten@transitionprobs,N@pescaperates,N@Flatten@ptransitionprobs,N@w0,N@z0,N@rmax]
)
]

]

FTSSimulateStateTrajectories[{species_Integer,brightnesslist:{FTSRateList..},p0:{_?FRealNumberQ..}}]:=Module[{dim=Length[p0]},
FTSSimulateStateTrajectories[{species,brightnesslist,p0,ConstantArray[0,{dim,dim}]}]
]
FTSSimulateStateTrajectories[{species_Integer,brightness:FTSRateList}]:=Module[{},
FTSSimulateStateTrajectories[{species,{brightness},{1},ConstantArray[0,{1,1}]}]
]
FTSSimulateStateTrajectories[specieslist:{_List..}]:=Map[FTSSimulateStateTrajectories,specieslist]

FTSClearStateTrajectories[SpeciesIndex_Integer]:=If[SpeciesIndex>0 && SpeciesIndex<=FTSGetNumberOfSpecies[],FTSClearStateTrajectoriesP[SpeciesIndex-1],0]
FTSClearStateTrajectories[]:=Do[FTSClearStateTrajectories[si],{si,1,FTSGetNumberOfSpecies[]}]


FTSSimulateFRETStateTrajectories[{species_Integer,rateparams:{{_?NumericQ, _?NumericQ, _?NumericQ}..},p0:{_?FRealNumberQ..},Kmatrix:_?(MatrixQ[#,FRealNumberQ]&), rcm:_?(MatrixQ[#,FRealNumberQ]&),AcceptorDirectExcitation_?NumericQ}]:=Module[{dim=Length[p0],escaperates,transitionprobs},
If[!(dim==Length[rateparams] && Dimensions[Kmatrix]=={dim,dim}),$Failed,
(
FTSSimulateFRETStateTrajectoriesP[species-1,N@AcceptorDirectExcitation,N@rateparams,N@p0,N@Kmatrix,N@rcm]
)
]
]

FTSSimulateFRETStateTrajectories[{species_Integer,rateparams:{{_?NumericQ, _?NumericQ, _?NumericQ}..},p0:{_?FRealNumberQ..},Kmatrix:_?(MatrixQ[#,FRealNumberQ]&),Kpowermatrix:_?(MatrixQ[#,FRealNumberQ]&), rcm:_?(MatrixQ[#,FRealNumberQ]&),AcceptorDirectExcitation_?NumericQ},w0_?FRealNumberQ,z0_?FRealNumberQ,rmax_?FRealNumberQ]:=Module[{dim=Length[p0],escaperates,transitionprobs,pescaperates,ptransitionprobs},
If[!(dim==Length[rateparams] && Dimensions[Kmatrix]=={dim,dim}),$Failed,
(
FTSSimulateFRETStateTrajectoriesPowerDependentP[species-1,AcceptorDirectExcitation,N@w0,N@z0,N@rmax,N@rateparams,N@p0,N@Kmatrix,N@Kpowermatrix,N@rcm]
)
]
]

FTSSimulateFRETStateTrajectories[{species_Integer,rateparams:{{_?NumericQ, _?NumericQ, _?NumericQ}..},p0:{_?FRealNumberQ..}}]:=Module[{dim=Length[p0]},
FTSSimulateFRETStateTrajectories[{species,rateparams,p0,ConstantArray[0,{dim,dim}]}]
]





FTSSimulateTTTR[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,z0_?NumberQ]:=FTSSimulateTTTRP[N@FExpandRoutelist@bg,N@rmax,N@w0,N@z0]
FTSSimulateTTTR[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ]:=FTSSimulateTTTR[bg,rmax,w0,w0]


FTSSimulateTTTRLifeTimes[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,z0_?NumberQ,decayrates:{{FTSRateList..}..}]:=FTSSimulateTTTRLifeTimesP[N@FExpandRoutelist@bg,N@rmax,N@w0,N@z0,Length/@decayrates,N@Flatten@ Map[FExpandRoutelist,decayrates,{2}]]


FTSSimulateTTTRLifeTimes[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,z0_?NumberQ,liftimedecays:{{{{_?NumberQ..}..}..}..},bgdecays:{{_?NumberQ..}..}]:=FTSSimulateTTTRLifeTimesP2[N@FExpandRoutelist@bg,N@rmax,N@w0,N@z0,N@liftimedecays,N@bgdecays]


FTSSimulateTTTRLifeTimes[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,decayrates:{{FTSRateList..}..}]:=FTSSimulateTTTRLifeTimes[bg,rmax,w0,w0,decayrates]


FTSGetIntensityTrajectory[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,z0_?NumberQ,start_Integer, bincount_Integer]:=FTSGetIntensityTrajectoryP[N@FExpandRoutelist@bg,N@rmax,N@w0,N@z0,start, bincount]
FTSGetIntensityTrajectory[bg:FTSRateList,rmax_?NumberQ,w0_?NumberQ,start_Integer, bincount_Integer]:=FTSGetIntensityTrajectory[bg,rmax,w0,w0,start, bincount]


FTSSaveTrajectories[filename_String]:=Module[{fn},
fn=StringReplace[ExpandFileName[filename],"\\"->"/"];
If[!FileExistsQ[fn],FTSSaveTrajectoriesP[fn],0]
]

FTSLoadTrajectories[filename_String]:=Module[{fn},
fn=StringReplace[ExpandFileName[filename],"\\"->"/"];
If[FileExistsQ[fn],FTSLoadTrajectoriesP[fn],0]
]


FSimulatePhotonTrajectory[p0_List,Kstatic_List,KFRET_List,VD_List,VA_List,kFTrajectory:{_?NumericQ..},EmissivityTrajD:{_?NumericQ..},EmissivityTrajA:{_?NumericQ..},substeps_Integer]:=Module[{},
If[Length[EmissivityTrajD]!=Length[kFTrajectory]|| Length[EmissivityTrajA]!=Length[kFTrajectory],Return[$Failed]];
FSimulatePhotonTrajectoryP[N@p0,N[Kstatic],N[KFRET],N[VD],N[VA],N@kFTrajectory,N@EmissivityTrajD,N@EmissivityTrajA,substeps]
]

FSimulatePhotonTrajectory[p0_List,Kstatic_List,KFRET_List,VD_List,VA_List,kFTrajectory:{_?NumericQ..},EmissivityTraj:{_?NumericQ..},substeps_Integer]:=FSimulatePhotonTrajectory[p0,Kstatic,KFRET,VD,VA,kFTrajectory,EmissivityTraj,EmissivityTraj,substeps]

FSimulatePhotonTrajectory[p0_List,Kstatic_List,KFRET_List,VD_List,VA_List,kFTrajectory:{_?NumericQ..},substeps_Integer]:=FSimulatePhotonTrajectory[p0,Kstatic,KFRET,VD,VA,kFTrajectory,ConstantArray[1.,Length[kFTrajectory]],ConstantArray[1.,Length[kFTrajectory]],substeps]


Options[FSimulateNanoSecondFCS]={FOutput->FData};
FSimulateNanoSecondFCS[p0:{_?NumericQ..},Kstatic_?FNumericMatrixQ,KFRET_?FNumericMatrixQ,VD_?FNumericMatrixQ,VA_?FNumericMatrixQ,kFTrajectory:{_?NumericQ..},EmissivityTrajD:{_?NumericQ..},EmissivityTrajA:{_?NumericQ..},dt_?NumericQ,substeps_Integer,taumax_?NumericQ,dtau_?NumericQ,repeats_Integer,opts:OptionsPattern[]]:=Module[{cdata,gdd,gda,gad,gaa,taulist,dtsub=N[dt/substeps]},
If[Length[EmissivityTrajD]!=Length[kFTrajectory]|| Length[EmissivityTrajA]!=Length[kFTrajectory],Return[$Failed]];cdata=FSimulateNanoSecondFCSP[N@p0,N[Kstatic]dtsub,N[KFRET]dtsub,N[VD]dtsub,N[VA]dtsub,N@kFTrajectory,N@EmissivityTrajD,N@EmissivityTrajA,substeps,Round[taumax/dtsub],Round[dtau/dtsub],repeats]/.(CorrelikonTimeUnitSec->_)->(CorrelikonTimeUnitSec->dtsub);
Which[
OptionValue[FOutput] === FData,
(
{gdd,gda,gad,gaa}=N@Map[FCorrelTransformRawData,cdata];
taulist=Join[-Reverse@gdd[[All,1]],gdd[[All,1]]];(*Range[-taumax+0.5dtau,taumax,dtau];*)Map[{taulist,#}\[Transpose]&,{Join[Reverse[gdd[[All,2]]],gdd[[All,2]]],Join[Reverse[gda[[All,2]]],gad[[All,2]]],Join[Reverse[gaa[[All,2]]],gaa[[All,2]]]}]
),
OptionValue[FOutput]===FRawData,
(cdata)
]

]

FSimulateNanoSecondFCS[p0:{_?NumericQ..},Kstatic_?FNumericMatrixQ,KFRET_?FNumericMatrixQ,VD_?FNumericMatrixQ,VA_?FNumericMatrixQ,kFTrajectory:{_?NumericQ..},EmissivityTraj:{_?NumericQ..},dt_?NumericQ,substeps_Integer,taumax_?NumericQ,dtau_?NumericQ,repeats_Integer,opts:OptionsPattern[]]:=FSimulateNanoSecondFCS[p0,Kstatic,KFRET,VD,VA,kFTrajectory,EmissivityTraj,EmissivityTraj,dt,substeps,taumax,dtau,repeats,opts]

FSimulateNanoSecondFCS[p0:{_?NumericQ..},Kstatic_?FNumericMatrixQ,KFRET_?FNumericMatrixQ,VD_?FNumericMatrixQ,VA_?FNumericMatrixQ,kFTrajectory:{_?NumericQ..},dt_?NumericQ,substeps_Integer,taumax_?NumericQ,dtau_?NumericQ,repeats_Integer,opts:OptionsPattern[]]:=FSimulateNanoSecondFCS[p0,Kstatic,KFRET,VD,VA,kFTrajectory,ConstantArray[1.,Length[kFTrajectory]],ConstantArray[1.,Length[kFTrajectory]],dt,substeps,taumax,dtau,repeats,opts]


 FMoveIn2DPot[r0:{{_,_}..},dt_,timesteps_Integer,k_,ktrans_,xC_,k4_]:= FMoveIn2DPotP[N@r0[[All,1]],N@r0[[All,2]],N@dt,timesteps,N@k,N@ktrans,N@xC,N@k4]
  FMoveIn2DPot[r0:{{_,_}..},dt_,timesteps_Integer,k_,ktrans_,xC_,k4_,ra_,rb_]:= FMoveIn2DPotP[N@r0[[All,1]],N@r0[[All,2]],N@dt,timesteps,N@k,N@ktrans,N@xC,N@k4,N@ra,N@rb]


FSimulatePullingInOpticalTrap[r0:{{_,_}..},dt_,timesteps_Integer,SnapshotPeriod_Integer,Dm_?NumericQ,DB_?NumericQ,x0_?NumericQ,DeltaG_?NumericQ,k_?NumericQ,FTrap_?NumericQ]:= FSimulatePullingInOpticalTrapP[N@r0[[All,1]],N@r0[[All,2]],N@dt,timesteps,SnapshotPeriod,N@Dm,N@DB,N@x0,N@DeltaG,N@k,N@FTrap]


FPDASettings[gamma_?NumericQ,crosstalk_?NumericQ,directexcitation_?NumericQ, bgA_?NumericQ, bgD_?NumericQ]:=FPDASettingsP[N@gamma,N@crosstalk,N@directexcitation, N@bgA, N@bgD]
FPDASetpF[pFdata:{{_?NumericQ..}..}]:=FPDASetpFP[Length/@pFdata,N@Flatten@pFdata]

Options[FPDACalcPSA]={FPDAMethod->"Approximate pF by pS"};
FPDACalcPSA[model:{{_?NumericQ,_?NumericQ,_?NumericQ}..},opts:OptionsPattern[]]:=Module[{params=N@Transpose[model],mode=If[OptionValue[FPDAMethod]==="Approximate pF by pS",1,0]},FPdaCalcPsaP[params[[1]]/Total[params[[1]]],params[[2]],params[[3]],mode]]
FPDAEhisto[e1_?NumericQ,e2_?NumericQ,bins_Integer,Smin_Integer]:=Module[{de=(e2-e1)/bins,p},
p=FPdaEhistoP[e1,e2,bins,Smin];
p/=Total[p];
{Table[e1+(i-0.5)de,{i,bins}],p}\[Transpose]
]



FProximityRatio[\[Alpha]_,\[Beta]_,\[Gamma]_][e_]:=((-1+e) (-1+\[Alpha]) \[Beta]+(e+\[Alpha]-e \[Alpha]) \[Gamma])/((-1+e) (-1+\[Alpha]) (1+\[Beta])+(e+\[Alpha]-e \[Alpha]) \[Gamma])


FBetaPeak[\[Mu]_,v_][p1_]:=\!\(\*
TagBox[GridBox[{
{"\[Piecewise]", GridBox[{
{
FractionBox[
RowBox[{
SuperscriptBox[
RowBox[{"(", 
RowBox[{"1", "-", "p1"}], ")"}], 
RowBox[{
RowBox[{"-", "1"}], "+", "v", "-", 
RowBox[{"v", " ", "\[Mu]"}]}]], " ", 
SuperscriptBox["p1", 
RowBox[{
RowBox[{"-", "1"}], "+", 
RowBox[{"v", " ", "\[Mu]"}]}]]}], 
RowBox[{"Beta", "[", 
RowBox[{
RowBox[{"v", " ", "\[Mu]"}], ",", 
RowBox[{"v", "-", 
RowBox[{"v", " ", "\[Mu]"}]}]}], "]"}]], 
RowBox[{"0", "<", "p1", "<", "1"}]},
{"0", 
TagBox["True",
"PiecewiseDefault",
AutoDelete->True]}
},
AllowedDimensions->{2, Automatic},
Editable->True,
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
Selectable->True]}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],
"Piecewise",
DeleteWithContents->True,
Editable->False,
SelectWithContents->True,
Selectable->False]\)


FpdaPofE[{\[Alpha]_,\[Beta]_,\[Gamma]_},{a_,emean_,\[Nu]_}][e_]:=a \!\(\*
TagBox[GridBox[{
{"\[Piecewise]", GridBox[{
{
RowBox[{"-", 
RowBox[{"(", 
RowBox[{
RowBox[{"(", 
RowBox[{"\[Gamma]", " ", 
SuperscriptBox[
RowBox[{"(", 
FractionBox[
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Beta]"}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"e", "+", "\[Alpha]", "-", 
RowBox[{"e", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]"}], ")"}]}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"e", "+", "\[Alpha]", "-", 
RowBox[{"e", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}]], ")"}], 
FractionBox[
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Beta]"}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"emean", "+", "\[Alpha]", "-", 
RowBox[{"emean", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], ")"}], " ", "\[Nu]"}], 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]"}], ")"}]}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"emean", "+", "\[Alpha]", "-", 
RowBox[{"emean", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}]]], " ", 
SuperscriptBox[
RowBox[{"(", 
FractionBox[
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}]}], 
RowBox[{"1", "+", "\[Beta]", "+", 
RowBox[{"e", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]", "-", "\[Gamma]"}], ")"}]}], "+", 
RowBox[{"\[Alpha]", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "-", "\[Beta]", "+", "\[Gamma]"}], ")"}]}]}]], ")"}], 
FractionBox[
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Nu]"}], 
RowBox[{"1", "+", "\[Beta]", "+", 
RowBox[{"emean", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]", "-", "\[Gamma]"}], ")"}]}], "+", 
RowBox[{"\[Alpha]", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "-", "\[Beta]", "+", "\[Gamma]"}], ")"}]}]}]]]}], ")"}], "/", 
RowBox[{"(", 
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Beta]"}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"e", "+", "\[Alpha]", "-", 
RowBox[{"e", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], ")"}], " ", 
RowBox[{"Beta", "[", 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Beta]"}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"emean", "+", "\[Alpha]", "-", 
RowBox[{"emean", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], ")"}], " ", "\[Nu]"}], ")"}], "/", 
RowBox[{"(", 
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]"}], ")"}]}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"emean", "+", "\[Alpha]", "-", 
RowBox[{"emean", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], ")"}]}], ",", 
FractionBox[
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "emean"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Nu]"}], 
RowBox[{"1", "+", "\[Beta]", "+", 
RowBox[{"emean", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]", "-", "\[Gamma]"}], ")"}]}], "+", 
RowBox[{"\[Alpha]", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "-", "\[Beta]", "+", "\[Gamma]"}], ")"}]}]}]]}], "]"}]}], ")"}]}], ")"}]}], 
RowBox[{"0", "<", 
FractionBox[
RowBox[{
RowBox[{
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "e"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", "\[Beta]"}], "+", 
RowBox[{
RowBox[{"(", 
RowBox[{"e", "+", "\[Alpha]", "-", 
RowBox[{"e", " ", "\[Alpha]"}]}], ")"}], " ", "\[Gamma]"}]}], 
RowBox[{"1", "+", "\[Beta]", "+", 
RowBox[{"e", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "+", "\[Alpha]"}], ")"}], " ", 
RowBox[{"(", 
RowBox[{"1", "+", "\[Beta]", "-", "\[Gamma]"}], ")"}]}], "+", 
RowBox[{"\[Alpha]", " ", 
RowBox[{"(", 
RowBox[{
RowBox[{"-", "1"}], "-", "\[Beta]", "+", "\[Gamma]"}], ")"}]}]}]], "<", "1"}]},
{"0", 
TagBox["True",
"PiecewiseDefault",
AutoDelete->True]}
},
AllowedDimensions->{2, Automatic},
Editable->True,
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.84]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
Selectable->True]}
},
GridBoxAlignment->{"Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxItemSize->{"Columns" -> {{Automatic}}, "ColumnsIndexed" -> {}, "Rows" -> {{1.}}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}},
GridBoxSpacings->{"Columns" -> {Offset[0.27999999999999997`], {Offset[0.35]}, Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {Offset[0.2], {Offset[0.4]}, Offset[0.2]}, "RowsIndexed" -> {}, "Items" -> {}, "ItemsIndexed" -> {}}],
"Piecewise",
DeleteWithContents->True,
Editable->False,
SelectWithContents->True,
Selectable->False]\)


FpdaIntrinsicDistribution[model:{{_,_,_}..}][p1_]:=Module[{n=Total[model[[All,1]]]},Map[#[[1]]/n FBetaPeak[#[[2]],#[[3]]][p1]&,model]]

FpdaIntrinsicDistribution[{\[Alpha]_,\[Beta]_,\[Gamma]_},model:{{_,_,_}..}][e_]:=Module[{n=Total[model[[All,1]]]},1/n Map[1/n FpdaPofE[{\[Alpha],\[Beta],\[Gamma]},#][e]&,model]]



FpdaGetReducedRCM[]:=Module[{aroutes,droutes,subrcms,rcm,weights,redrcm},
rcm=FGetRCM[];
aroutes=Flatten@MapIndexed[If[#1==1,#2,Nothing[]]&,FGetAcceptorRoutes[]];
droutes=Flatten@MapIndexed[If[#1==1,#2,Nothing[]]&,FGetDonorRoutes[]];
subrcms=Map[rcm[[#,#]]&,{aroutes,droutes}\[Transpose]];
weights=1/subrcms[[All,1,1]];
redrcm=Total[weights^2 subrcms]/Total[weights];
redrcm/=redrcm[[1,1]];
redrcm
]


FpdaGetCorrectionFactors\[Alpha]\[Beta]\[Gamma][]:=Module[{rcm,\[Alpha],\[Beta],\[Gamma]},
rcm=FpdaGetReducedRCM[];
\[Gamma]=rcm[[2,2]];
\[Beta]=-rcm[[1,2]];
\[Alpha]=FGetDirectAcceptorExcitation[];
{\[Alpha],\[Beta],\[Gamma]}
]


FpdaGetDABackground[bg_,Tmean_]:=Module[{aroutes,droutes},
aroutes=Flatten@MapIndexed[If[#1==1,#2,Nothing[]]&,FGetAcceptorRoutes[]];
droutes=Flatten@MapIndexed[If[#1==1,#2,Nothing[]]&,FGetDonorRoutes[]];
Tmean{Total[bg[[droutes]]],Total@bg[[aroutes]]}
]
FpdaGetDABackground[bg_]:=FpdaGetDABackground[bg,Mean@FGetFromBurstList["BurstDuration"]];
FpdaGetDABackground[]:= FpdaGetDABackground[FGetBackground[]]


FpdaAutoselectSmin[pF:{{_?NumericQ..}..}]:=Min[Table[LengthWhile[pF[[i]],#<=0&],{i,Length[pF]}]]


Clear[FpdaGetSubPopBurstSizeDistributions]
Options[FpdaGetSubPopBurstSizeDistributions]=Options[FGetFromBurstList];
FpdaGetSubPopBurstSizeDistributions[eranges:{{_?NumericQ,_?NumericQ}...},Fmax_Integer,{elist:{_?NumericQ...},burstsizelist:{_?NumericQ...}}]:=Module[{eselect,pF},
eselect[{e1_,e2_}]:=(pF=BinCounts[Select[{elist,burstsizelist}\[Transpose],e1<=#[[1]]<e2&][[All,2]],{0,Fmax,1}];pF/=N@Total[pF];
pF);
eselect/@eranges
]
FpdaGetSubPopBurstSizeDistributions[eranges:{{_?NumericQ,_?NumericQ}...},Fmax_Integer,opts:OptionsPattern[]]:=FpdaGetSubPopBurstSizeDistributions[eranges,Fmax,FGetFromBurstList[{"E","nA_raw"+"nD_raw"},FilterRules[{opts},Options[FGetFromBurstList]]]]



Options[FpdaEHistoSubpopulations]={FpdaDonly->True,FPDAMethod->"Approximate pF by pS"};
FpdaEHistoSubpopulations[ehisto:{{_?NumericQ,_?NumericQ,_?NumericQ}...},pF:{{_?NumericQ..}..},model:{{_?NumericQ,_?NumericQ,_?NumericQ}..},{bgD_?NumericQ,bgA_?NumericQ},opts:OptionsPattern[]]:=Module[{\[Alpha],\[Beta],\[Gamma],betamax,pamodel,mhisto,nbursts,e1,e2,de, subfunc,subpopplstyle,pldat,plpda,plsubpop,scale,smin},
If[Length[model]!=Length[pF],Message[FpdaEHisto::dimerr];Return[$Failed]];

smin=FpdaAutoselectSmin[pF];
{\[Alpha],\[Beta],\[Gamma]}=FpdaGetCorrectionFactors\[Alpha]\[Beta]\[Gamma][];

pamodel=Abs@model;
pamodel[[All,2]]=Map[FProximityRatio[\[Alpha],\[Beta],\[Gamma]],pamodel[[All,2]]];
If[OptionValue[FpdaDonly]===True,
pamodel[[1,2]]=FProximityRatio[0,\[Beta],\[Gamma]][model[[1,2]]]
];
nbursts=Total[ehisto[[All,2]]];
de=ehisto[[2,1]]-ehisto[[1,1]];
e1=ehisto[[1,1]]-0.5 de;
e2=ehisto[[-1,1]]+ 0.5de;
FPDASettings[\[Gamma],\[Beta],\[Alpha],bgA,bgD];
Table[
FPDASetpF[pF[[i;;i]]];
FPDACalcPSA[pamodel[[i;;i]],FilterRules[{opts},Options[FPDACalcPSA]]];
mhisto=FPDAEhisto[e1,e2,Length[ehisto],smin];
mhisto[[All,2]]*=nbursts*model[[i,1]];
Append[de]/@mhisto
,{i,Length[model]}]

]






Clear[FpdaEHisto]
Options[FpdaEHisto]={FpdaShowIntrinsicDistribution->True,FpdaIntrinsicDistributionPlotOptions->{PlotStyle->Darker@Green},FOutput->FGraph,FpdaDonly->True,FPDAMethod->"Approximate pF by pS",FFitCurveOptions->{},FSubPopCurveOptions->{}}~Join~Options[Graphics]~Join~Options[FPlotHisto]~Join~Options[FGetFromBurstList];

FpdaEHisto[ehisto:{{_?NumericQ,_?NumericQ,_?NumericQ}...},pF:{{_?NumericQ..}..},model:{{_?NumericQ,_?NumericQ,_?NumericQ}..},{bgD_?NumericQ,bgA_?NumericQ},opts:OptionsPattern[]]:=Module[{\[Alpha],\[Beta],\[Gamma],betamax,pamodel,mhisto,nbursts,e1,e2,de, subfunc,subpopplstyle,pldat,plpda,plintrinsic,plsubpop,plall,scale,smin},
If[Length[model]!=Length[pF],Message[FpdaEHisto::dimerr];Return[$Failed]];
(*betamax[{\[Mu]_,\[Nu]_}]:=\[Piecewise]	(((-1+\[Nu]-\[Mu] \[Nu])/(-2+\[Nu]))^(-1+\[Nu]-\[Mu] \[Nu]) ((-1+\[Mu] \[Nu])/(-2+\[Nu]))^(-1+\[Mu] \[Nu]))/Beta[\[Mu] \[Nu],\[Nu]-\[Mu] \[Nu]]	0<(-1+\[Mu] \[Nu])/(-2+\[Nu])<1
0	True

;*)

(*betamax[{a_,\[Mu]_,\[Nu]_}]:=FpdaPofE[{\[Alpha],\[Beta],\[Gamma]},{a,\[Mu],\[Nu]}][\[Mu]];*)
smin=FpdaAutoselectSmin[pF];
{\[Alpha],\[Beta],\[Gamma]}=FpdaGetCorrectionFactors\[Alpha]\[Beta]\[Gamma][];
FPDASettings[\[Gamma],\[Beta],\[Alpha],bgA,bgD];
FPDASetpF[pF];
pamodel=Abs@model;
pamodel[[All,2]]=Map[FProximityRatio[\[Alpha],\[Beta],\[Gamma]],pamodel[[All,2]]];
If[OptionValue[FpdaDonly]===True,
pamodel[[1,2]]=FProximityRatio[0,\[Beta],\[Gamma]][model[[1,2]]]
];
FPDACalcPSA[pamodel,FilterRules[{opts},Options[FPDACalcPSA]]];
nbursts=Total[ehisto[[All,2]]];
de=ehisto[[2,1]]-ehisto[[1,1]];
e1=ehisto[[1,1]]-0.5 de;
e2=ehisto[[-1,1]]+ 0.5de;
mhisto=FPDAEhisto[e1,e2,Length[ehisto],smin];
mhisto[[All,2]]*=nbursts*Total[model[[All,1]]];
mhisto=Append[de]/@mhisto;
If[OptionValue[FOutput]===FGraph,

pldat=FPlotHisto[ehisto,FilterRules[{opts},Options[FPlotHisto]],PlotRange->All];


plpda=FPlotContourHisto[mhisto,Sequence@@OptionValue[FFitCurveOptions],PlotRange->All,PlotStyle->Directive[Red,AbsoluteThickness[1.5]],Filling->Axis,FillingStyle->Directive[White,Opacity[0.2]]];

plsubpop=FPlotContourHisto[FpdaEHistoSubpopulations[ehisto,pF,model,{bgD,bgA},FilterRules[{opts},Options[FpdaEHistoSubpopulations]]],Sequence@@OptionValue[FSubPopCurveOptions],PlotRange->All];
plall=Show[pldat,plsubpop,plpda,FilterRules[{opts},Options[Graphics]],ImageSize->400,AspectRatio->1/2,Axes->False,Frame->True,LabelStyle->{FontFamily->"Helvetica",FontSize->12,FontWeight->Bold},FrameStyle->Directive[Black,AbsoluteThickness[1]],FrameLabel->{"E","# (total: "<>ToString[Total@ehisto[[All,2]]]<>")"}];

If[OptionValue[FpdaShowIntrinsicDistribution]===True,
(
plintrinsic=Plot[Evaluate[FpdaIntrinsicDistribution[{\[Alpha],\[Beta],\[Gamma]},model][e]],{e,e1,e2},Evaluate[OptionValue[FpdaIntrinsicDistributionPlotOptions]],PlotRange->All];
plintrinsic=Show[plintrinsic,ImageSize->400,AspectRatio->0.2,Axes->False,Frame->True,LabelStyle->{FontFamily->"Helvetica",FontSize->12,FontWeight->Bold},FrameStyle->Directive[Black,AbsoluteThickness[1]],FrameLabel->{"E",""}];
Column[{plall,plintrinsic}]),plall]
,mhisto]
]

FpdaEHisto[ehisto:{{_?NumericQ,_?NumericQ,_?NumericQ}...},pF:{{_?NumericQ..}..},model:{{_?NumericQ,_?NumericQ,_?NumericQ}..},opts:OptionsPattern[]]:=FpdaEHisto[ehisto,pF,model,FpdaGetDABackground[],opts]

FpdaEHisto[erange:{e1_?NumericQ,e2_?NumericQ,de_?NumericQ},x__,opts:OptionsPattern[]]:=FpdaEHisto[FParamHisto["E",erange,FOutput->FData,FilterRules[{opts},Options[FGetFromBurstList]]],x,opts]


FpdaChiqr[ehisto_,model:{{_?NumberQ,_?NumberQ,_?NumberQ}..},smin_]:=Module[{mhisto,diff,nbursts,e1,e2,de},

nbursts=Total[ehisto[[All,2]]];
de=ehisto[[2,1]]-ehisto[[1,1]];
e1=ehisto[[1,1]]-0.5 de;
e2=ehisto[[-1,1]]+ 0.5de;
FPDACalcPSA[model][model];
mhisto=FPDAEhisto[e1,e2,Length[ehisto],smin];
mhisto[[All,2]]*=nbursts*Total[model[[All,1]]];
diff=ehisto[[All,2]]-mhisto[[All,2]];
diff . diff
]


FpdaChiqrGlobal[ehistolist_,modellist_,smin_]:=Module[{},
Total@MapThread[FpdaChiqr[#1,#2,smin]&,{ehistolist,modellist}]
]


Clear[FpdaFitEHisto];
Options[FpdaFitEHisto]=Join[{FpdaDonly->True,FConstraints->None},Options[FpdaEHisto],Options[FindMinimum]];

FpdaFitEHisto[ehisto:{{_?NumericQ,_?NumericQ,_?NumericQ}...},pF:{{_?NumericQ..}..},model:{{_,_,_}..},guess_List,{bgD_?NumericQ,bgA_?NumericQ},opts:OptionsPattern[]]:=
Module[{\[Alpha],\[Beta],\[Gamma],smin,fit,pamodel,meritfunc},
If[Length[model]!=Length[pF],Message[FpdaFitEHisto::dimerr];Return[$Failed]];
smin=FpdaAutoselectSmin[pF];
{\[Alpha],\[Beta],\[Gamma]}=FpdaGetCorrectionFactors\[Alpha]\[Beta]\[Gamma][];
FPDASettings[\[Gamma],\[Beta],\[Alpha],bgA,bgD];
FPDASetpF[pF];
pamodel=Abs@model;
pamodel[[All,2]]=Map[FProximityRatio[\[Alpha],\[Beta],\[Gamma]],pamodel[[All,2]]];
If[OptionValue[FpdaDonly]===True,
pamodel[[1,2]]=FProximityRatio[0,\[Beta],\[Gamma]][model[[1,2]]]
];
meritfunc=If[OptionValue[FConstraints]=!=None,{FpdaChiqr[ehisto,pamodel,smin],OptionValue[FConstraints]},FpdaChiqr[ehisto,pamodel,smin]];
fit=FindMinimum[meritfunc,guess,Evaluate[FilterRules[{opts},Options[FindMinimum]]],AccuracyGoal->3];
{fit,FpdaEHisto[ehisto,pF,model/.fit[[2]],{bgD,bgA},FilterRules[{opts},Options[FpdaEHisto]]]}
]
FpdaFitEHisto[ehisto:{{_?NumericQ,_?NumericQ,_?NumericQ}...},pF:{{_?NumericQ..}..},model:{{_,_,_}..},guess_List,opts:OptionsPattern[]]:=FpdaFitEHisto[ehisto,pF,model,guess,FpdaGetDABackground[],opts]
FpdaFitEHisto[erange:{e1_?NumericQ,e2_?NumericQ,de_?NumericQ},x__]:=FpdaFitEHisto[FParamHisto["E",erange,FOutput->FData],x]


FpdaFitEHisto[ehisto:{{{_?NumericQ,_?NumericQ,_?NumericQ}...}..},pF:{{_?NumericQ..}..},model:{{{_,_,_}..}..},guess_List,{bgD_?NumericQ,bgA_?NumericQ},opts:OptionsPattern[]]:=Module[{\[Alpha],\[Beta],\[Gamma],smin,fit,pamodel,meritfunc},
If[Length[model]!=Length[ehisto],Message[FpdaFitEHisto::dimerr];Return[$Failed]];
If[Or@@Map[Length[#]!=Length[pF]&,model],Message[FpdaFitEHisto::dimerr];Return[$Failed]];
smin=FpdaAutoselectSmin[pF];
{\[Alpha],\[Beta],\[Gamma]}=FpdaGetCorrectionFactors\[Alpha]\[Beta]\[Gamma][];
FPDASettings[\[Gamma],\[Beta],\[Alpha],bgA,bgD];
FPDASetpF[pF];
pamodel=Abs@model;
pamodel[[All,All,2]]=Map[FProximityRatio[\[Alpha],\[Beta],\[Gamma]],pamodel[[All,All,2]]];
If[OptionValue[FpdaDonly]===True,
pamodel[[All,1,2]]=FProximityRatio[0,\[Beta],\[Gamma]][model[[All,1,2]]]
];
meritfunc=If[OptionValue[FConstraints]=!=None,{FpdaChiqrGlobal[ehisto,pamodel,smin],OptionValue[FConstraints]},FpdaChiqrGlobal[ehisto,pamodel,smin]];
fit=FindMinimum[meritfunc,guess,Evaluate[FilterRules[{opts},Options[FindMinimum]]],AccuracyGoal->3];
{fit,MapThread[FpdaEHisto[#1,pF,#2,{bgD,bgA},FilterRules[{opts},Options[FpdaEHisto]]]&,{ehisto,model/.fit[[2]]}]}
]
FpdaFitEHisto[ehisto:{{{_?NumericQ,_?NumericQ,_?NumericQ}...}..},pF:{{_?NumericQ..}..},model:{{{_,_,_}..}..},guess_List,opts:OptionsPattern[]]:=FpdaFitEHisto[ehisto,pF,model,guess,FpdaGetDABackground[],opts]


End[];


(* :Code Section (Call Protect): *)


EndPackage[];


Print[FAboutFretica[]];
